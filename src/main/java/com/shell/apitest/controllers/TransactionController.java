/*
 * ShellDataReportingAPIsLib
 *
 * This file was automatically generated by APIMATIC v3.0 ( https://www.apimatic.io ).
 */

package com.shell.apitest.controllers;

import com.fasterxml.jackson.core.JsonProcessingException;
import com.shell.apitest.ApiHelper;
import com.shell.apitest.Server;
import com.shell.apitest.exceptions.ApiException;
import com.shell.apitest.exceptions.DefaultErrorException;
import com.shell.apitest.exceptions.ErrorObjectException;
import com.shell.apitest.exceptions.ErrorUserAccessError1Exception;
import com.shell.apitest.http.request.HttpMethod;
import com.shell.apitest.models.CardUsageSummaryRequest;
import com.shell.apitest.models.CardUsageSummaryResponse;
import com.shell.apitest.models.FeeSummaryResponse;
import com.shell.apitest.models.FuelConsumptionRequest;
import com.shell.apitest.models.FuelConsumptionResponse;
import com.shell.apitest.models.MultiPricedTransactionRequest;
import com.shell.apitest.models.MultiPricedTransactionResponse;
import com.shell.apitest.models.PriceTransSummaryRequest;
import com.shell.apitest.models.PriceTransactionRequest;
import com.shell.apitest.models.PricedTransSummaryResponse;
import com.shell.apitest.models.PricedTransactionRequestV2;
import com.shell.apitest.models.PricedTransactionResponse;
import com.shell.apitest.models.PricedTransactionResponseV2;
import com.shell.apitest.models.RecentTransactionRequest;
import com.shell.apitest.models.RecentTransactionsResponse;
import com.shell.apitest.models.TransactionExceptionsRequest;
import com.shell.apitest.models.TransactionExceptionsResponse;
import com.shell.apitest.models.TransactionFeesRequest;
import com.shell.apitest.models.TransactionFeesResponse;
import com.shell.apitest.models.UpdateOdometerRequest;
import com.shell.apitest.models.UpdateOdometerResponse;
import com.shell.apitest.models.VolumeBasedBonusRequest;
import com.shell.apitest.models.VolumeBasedBonusResponse;
import com.shell.apitest.models.VolumeBasedPricingRequest;
import com.shell.apitest.models.VolumeBasedPricingResponse;
import io.apimatic.core.ApiCall;
import io.apimatic.core.ErrorCase;
import io.apimatic.core.GlobalConfiguration;
import java.io.IOException;
import java.util.concurrent.CompletableFuture;
import java.util.concurrent.CompletionException;

/**
 * This class lists all the endpoints of the groups.
 */
public final class TransactionController extends BaseController {

    /**
     * Initializes the controller.
     * @param globalConfig    Configurations added in client.
     */
    public TransactionController(GlobalConfiguration globalConfig) {
        super(globalConfig);
    }

    /**
     * This API allows querying transaction data (i.e. Priced, Billed and Unbilled sales items). It
     * provides a flexible search criteria and supports paging. Transactions that are posted but not
     * yet priced, billed or that are in error will not be returned by this API. The API also
     * supports returning Fee Items. #### Supported operations * Get sales items and fee
     * transactions * Search by invoice status * Search by fixed date period * Search by date range
     * * Search by account * Search by card * Get sales items only * Search by transaction Id or
     * location * Search by transaction posting date * Search by invoice number or date * Search by
     * driver name or vehicle registration number * Search by card group * Search by fuel only
     * transactions * Search by product This API fetches transactions for a period based on the
     * below parameters and priority order: 1.	InvoiceNumber 2.	InvoiceDate 3.	FromDate, ToDate
     * 4.	PostingFromDate, PostingToDate (Can be used only when IncludeFees = false)
     * 5.	InvoiceDateFrom, InvoiceDateTo 6.	Period This API considers only one of the above set of
     * parameters at a time. For example, if InvoiceNumber and Period are provided in the input then
     * Period is ignored and transactions associated to the given invoice number are returned. If
     * none of the above parameters are provided then last 7 days transactions will be fetched. This
     * operation can fetch transactions that are old up to 24 (configurable) months. However, the
     * date range between any of the ‘From’ and ‘To’ dates in the above combination cannot be more
     * than 210 (configurable) days.
     * @param  apikey  Required parameter: This is the API key of the specific environment which
     *         needs to be passed by the client.
     * @param  requestId  Required parameter: Mandatory UUID (according to RFC 4122 standards) for
     *         requests and responses. This will be played back in the response from the request.
     * @param  body  Optional parameter: Priced Transaction Request Body
     * @return    Returns the PricedTransactionResponse response from the API call
     * @throws    ApiException    Represents error response from the server.
     * @throws    IOException    Signals that an I/O exception of some sort has occurred.
     */
    public PricedTransactionResponse pricedTransactions(
            final String apikey,
            final String requestId,
            final PriceTransactionRequest body) throws ApiException, IOException {
        return preparePricedTransactionsRequest(apikey, requestId, body).execute();
    }

    /**
     * This API allows querying transaction data (i.e. Priced, Billed and Unbilled sales items). It
     * provides a flexible search criteria and supports paging. Transactions that are posted but not
     * yet priced, billed or that are in error will not be returned by this API. The API also
     * supports returning Fee Items. #### Supported operations * Get sales items and fee
     * transactions * Search by invoice status * Search by fixed date period * Search by date range
     * * Search by account * Search by card * Get sales items only * Search by transaction Id or
     * location * Search by transaction posting date * Search by invoice number or date * Search by
     * driver name or vehicle registration number * Search by card group * Search by fuel only
     * transactions * Search by product This API fetches transactions for a period based on the
     * below parameters and priority order: 1.	InvoiceNumber 2.	InvoiceDate 3.	FromDate, ToDate
     * 4.	PostingFromDate, PostingToDate (Can be used only when IncludeFees = false)
     * 5.	InvoiceDateFrom, InvoiceDateTo 6.	Period This API considers only one of the above set of
     * parameters at a time. For example, if InvoiceNumber and Period are provided in the input then
     * Period is ignored and transactions associated to the given invoice number are returned. If
     * none of the above parameters are provided then last 7 days transactions will be fetched. This
     * operation can fetch transactions that are old up to 24 (configurable) months. However, the
     * date range between any of the ‘From’ and ‘To’ dates in the above combination cannot be more
     * than 210 (configurable) days.
     * @param  apikey  Required parameter: This is the API key of the specific environment which
     *         needs to be passed by the client.
     * @param  requestId  Required parameter: Mandatory UUID (according to RFC 4122 standards) for
     *         requests and responses. This will be played back in the response from the request.
     * @param  body  Optional parameter: Priced Transaction Request Body
     * @return    Returns the PricedTransactionResponse response from the API call
     */
    public CompletableFuture<PricedTransactionResponse> pricedTransactionsAsync(
            final String apikey,
            final String requestId,
            final PriceTransactionRequest body) {
        try { 
            return preparePricedTransactionsRequest(apikey, requestId, body).executeAsync(); 
        } catch (Exception e) {  
            throw new CompletionException(e); 
        }
    }

    /**
     * Builds the ApiCall object for pricedTransactions.
     */
    private ApiCall<PricedTransactionResponse, ApiException> preparePricedTransactionsRequest(
            final String apikey,
            final String requestId,
            final PriceTransactionRequest body) throws JsonProcessingException, IOException {
        return new ApiCall.Builder<PricedTransactionResponse, ApiException>()
                .globalConfig(getGlobalConfiguration())
                .requestBuilder(requestBuilder -> requestBuilder
                        .server(Server.SHELL.value())
                        .path("/fleetmanagement/v1/transaction/pricedtransactions")
                        .bodyParam(param -> param.value(body).isRequired(false))
                        .bodySerializer(() ->  ApiHelper.serialize(body))
                        .headerParam(param -> param.key("apikey")
                                .value(apikey).isRequired(false))
                        .headerParam(param -> param.key("RequestId")
                                .value(requestId).isRequired(false))
                        .headerParam(param -> param.key("Content-Type")
                                .value("application/json").isRequired(false))
                        .headerParam(param -> param.key("accept").value("application/json"))
                        .withAuth(auth -> auth
                                .add("BasicAuth"))
                        .httpMethod(HttpMethod.POST))
                .responseHandler(responseHandler -> responseHandler
                        .deserializer(
                                response -> ApiHelper.deserialize(response, PricedTransactionResponse.class))
                        .nullify404(false)
                        .localErrorCase("400",
                                 ErrorCase.setReason("The server cannot or will not process the request  due to something that is perceived to be a client\r\n error (e.g., malformed request syntax, invalid \r\n request message framing, or deceptive request routing).",
                                (reason, context) -> new DefaultErrorException(reason, context)))
                        .localErrorCase("401",
                                 ErrorCase.setReason("The request has not been applied because it lacks valid  authentication credentials for the target resource.\r\n",
                                (reason, context) -> new DefaultErrorException(reason, context)))
                        .localErrorCase("403",
                                 ErrorCase.setReason("The server understood the request but refuses to authorize it.\r\n",
                                (reason, context) -> new ErrorUserAccessError1Exception(reason, context)))
                        .localErrorCase("404",
                                 ErrorCase.setReason("The origin server did not find a current representation  for the target resource or is not willing to disclose  that one exists.\r\n",
                                (reason, context) -> new DefaultErrorException(reason, context)))
                        .localErrorCase("500",
                                 ErrorCase.setReason("The server encountered an unexpected condition the prevented it from fulfilling the request.\r\n",
                                (reason, context) -> new DefaultErrorException(reason, context)))
                        .globalErrorCase(GLOBAL_ERROR_CASES))
                .build();
    }

    /**
     * This API returns the transaction summary data (i.e. Priced, Billed and Unbilled sales items).
     * It provides a flexible search criteria. The API also supports returning Fee Items.
     * Transactions posted for fee items that are in error are not included in the summary. The
     * endpoint supports the exact same search criteria as the endpoint
     * *transaction/prciedtransactions*. #### Supported operations * Get sales items and fee
     * transactions * Search by invoice status * Search by fixed date period * Search by date range
     * * Search by account * Search by card * Get sales items only * Search by transaction Id or
     * location * Search by transaction posting date * Search by invoice number or date * Search by
     * driver name or vehicle registration number * Search by card group * Search by fuel only
     * transactions * Search by product This API fetches transactions for a period based on the
     * below parameters and priority order: 1.	InvoiceNumber 2.	InvoiceDate 3.	FromDate, ToDate
     * 4.	PostingFromDate, PostingToDate (Can be used only when IncludeFees = false)
     * 5.	InvoiceDateFrom, InvoiceDateTo 6.	Period This API considers only one of the above set of
     * parameters at a time. For example, if InvoiceNumber and Period are provided in the input then
     * Period is ignored and transactions associated to the given invoice number are returned. If
     * none of the above parameters are provided then last 7 days transactions will be fetched.
     * @param  apikey  Required parameter: This is the API key of the specific environment which
     *         needs to be passed by the client.
     * @param  requestId  Required parameter: Mandatory UUID (according to RFC 4122 standards) for
     *         requests and responses. This will be played back in the response from the request.
     * @param  body  Optional parameter: PricedSummary RequestBody
     * @return    Returns the PricedTransSummaryResponse response from the API call
     * @throws    ApiException    Represents error response from the server.
     * @throws    IOException    Signals that an I/O exception of some sort has occurred.
     */
    public PricedTransSummaryResponse pricedTransactionsSummary(
            final String apikey,
            final String requestId,
            final PriceTransSummaryRequest body) throws ApiException, IOException {
        return preparePricedTransactionsSummaryRequest(apikey, requestId, body).execute();
    }

    /**
     * This API returns the transaction summary data (i.e. Priced, Billed and Unbilled sales items).
     * It provides a flexible search criteria. The API also supports returning Fee Items.
     * Transactions posted for fee items that are in error are not included in the summary. The
     * endpoint supports the exact same search criteria as the endpoint
     * *transaction/prciedtransactions*. #### Supported operations * Get sales items and fee
     * transactions * Search by invoice status * Search by fixed date period * Search by date range
     * * Search by account * Search by card * Get sales items only * Search by transaction Id or
     * location * Search by transaction posting date * Search by invoice number or date * Search by
     * driver name or vehicle registration number * Search by card group * Search by fuel only
     * transactions * Search by product This API fetches transactions for a period based on the
     * below parameters and priority order: 1.	InvoiceNumber 2.	InvoiceDate 3.	FromDate, ToDate
     * 4.	PostingFromDate, PostingToDate (Can be used only when IncludeFees = false)
     * 5.	InvoiceDateFrom, InvoiceDateTo 6.	Period This API considers only one of the above set of
     * parameters at a time. For example, if InvoiceNumber and Period are provided in the input then
     * Period is ignored and transactions associated to the given invoice number are returned. If
     * none of the above parameters are provided then last 7 days transactions will be fetched.
     * @param  apikey  Required parameter: This is the API key of the specific environment which
     *         needs to be passed by the client.
     * @param  requestId  Required parameter: Mandatory UUID (according to RFC 4122 standards) for
     *         requests and responses. This will be played back in the response from the request.
     * @param  body  Optional parameter: PricedSummary RequestBody
     * @return    Returns the PricedTransSummaryResponse response from the API call
     */
    public CompletableFuture<PricedTransSummaryResponse> pricedTransactionsSummaryAsync(
            final String apikey,
            final String requestId,
            final PriceTransSummaryRequest body) {
        try { 
            return preparePricedTransactionsSummaryRequest(apikey, requestId, body).executeAsync(); 
        } catch (Exception e) {  
            throw new CompletionException(e); 
        }
    }

    /**
     * Builds the ApiCall object for pricedTransactionsSummary.
     */
    private ApiCall<PricedTransSummaryResponse, ApiException> preparePricedTransactionsSummaryRequest(
            final String apikey,
            final String requestId,
            final PriceTransSummaryRequest body) throws JsonProcessingException, IOException {
        return new ApiCall.Builder<PricedTransSummaryResponse, ApiException>()
                .globalConfig(getGlobalConfiguration())
                .requestBuilder(requestBuilder -> requestBuilder
                        .server(Server.SHELL.value())
                        .path("/fleetmanagement/v1/transaction/pricedtransactionssummary")
                        .bodyParam(param -> param.value(body).isRequired(false))
                        .bodySerializer(() ->  ApiHelper.serialize(body))
                        .headerParam(param -> param.key("apikey")
                                .value(apikey).isRequired(false))
                        .headerParam(param -> param.key("RequestId")
                                .value(requestId).isRequired(false))
                        .headerParam(param -> param.key("Content-Type")
                                .value("application/json").isRequired(false))
                        .headerParam(param -> param.key("accept").value("application/json"))
                        .withAuth(auth -> auth
                                .add("BasicAuth"))
                        .httpMethod(HttpMethod.POST))
                .responseHandler(responseHandler -> responseHandler
                        .deserializer(
                                response -> ApiHelper.deserialize(response, PricedTransSummaryResponse.class))
                        .nullify404(false)
                        .localErrorCase("400",
                                 ErrorCase.setReason("The server cannot or will not process the request  due to something that is perceived to be a client\r\n error (e.g., malformed request syntax, invalid \r\n request message framing, or deceptive request routing).",
                                (reason, context) -> new DefaultErrorException(reason, context)))
                        .localErrorCase("401",
                                 ErrorCase.setReason("The request has not been applied because it lacks valid  authentication credentials for the target resource.\r\n",
                                (reason, context) -> new DefaultErrorException(reason, context)))
                        .localErrorCase("403",
                                 ErrorCase.setReason("The server understood the request but refuses to authorize it.\r\n",
                                (reason, context) -> new ErrorUserAccessError1Exception(reason, context)))
                        .localErrorCase("404",
                                 ErrorCase.setReason("The origin server did not find a current representation  for the target resource or is not willing to disclose  that one exists.\r\n",
                                (reason, context) -> new DefaultErrorException(reason, context)))
                        .localErrorCase("500",
                                 ErrorCase.setReason("The server encountered an unexpected condition the prevented it from fulfilling the request.\r\n",
                                (reason, context) -> new DefaultErrorException(reason, context)))
                        .globalErrorCase(GLOBAL_ERROR_CASES))
                .build();
    }

    /**
     * This API allows querying transaction data (i.e. Priced, Billed and Unbilled sales items) for
     * multiple payers. It provides a flexible search criteria and supports paging. Transactions
     * that are posted but not yet priced, billed or that are in error will not be returned by this
     * API. The API also supports returning Fee Items. At least one payer should be provided.
     * Multiple payers must belong to the same payer group. #### Supported operations * Get sales
     * items and fee transactions for multiple payers * Search by invoice status * Search by fixed
     * date period * Search by date range * Get sales items only for multiple payers * Search by
     * transaction location * Search by transaction posting date * Search by invoice number or date
     * * Search by fuel only transactions This API fetches transactions for a period based on the
     * below parameters and priority order: 1.	InvoiceNumber 2.	InvoiceDate 3.	FromDate, ToDate
     * 4.	PostingFromDate, PostingToDate (Can be used only when IncludeFees = false)
     * 5.	InvoiceDateFrom, InvoiceDateTo 6.	Period This API considers only one of the above set of
     * parameters at a time. For example, if InvoiceNumber and Period are provided in the input then
     * Period is ignored and transactions associated to the given invoice number are returned. If
     * none of the above parameters are provided then last 7 days transactions will be fetched.
     * @param  apikey  Required parameter: This is the API key of the specific environment which
     *         needs to be passed by the client.
     * @param  requestId  Required parameter: Mandatory UUID (according to RFC 4122 standards) for
     *         requests and responses. This will be played back in the response from the request.
     * @param  body  Optional parameter: MultiPayer RequestBody
     * @return    Returns the MultiPricedTransactionResponse response from the API call
     * @throws    ApiException    Represents error response from the server.
     * @throws    IOException    Signals that an I/O exception of some sort has occurred.
     */
    public MultiPricedTransactionResponse multipricedTransactions(
            final String apikey,
            final String requestId,
            final MultiPricedTransactionRequest body) throws ApiException, IOException {
        return prepareMultipricedTransactionsRequest(apikey, requestId, body).execute();
    }

    /**
     * This API allows querying transaction data (i.e. Priced, Billed and Unbilled sales items) for
     * multiple payers. It provides a flexible search criteria and supports paging. Transactions
     * that are posted but not yet priced, billed or that are in error will not be returned by this
     * API. The API also supports returning Fee Items. At least one payer should be provided.
     * Multiple payers must belong to the same payer group. #### Supported operations * Get sales
     * items and fee transactions for multiple payers * Search by invoice status * Search by fixed
     * date period * Search by date range * Get sales items only for multiple payers * Search by
     * transaction location * Search by transaction posting date * Search by invoice number or date
     * * Search by fuel only transactions This API fetches transactions for a period based on the
     * below parameters and priority order: 1.	InvoiceNumber 2.	InvoiceDate 3.	FromDate, ToDate
     * 4.	PostingFromDate, PostingToDate (Can be used only when IncludeFees = false)
     * 5.	InvoiceDateFrom, InvoiceDateTo 6.	Period This API considers only one of the above set of
     * parameters at a time. For example, if InvoiceNumber and Period are provided in the input then
     * Period is ignored and transactions associated to the given invoice number are returned. If
     * none of the above parameters are provided then last 7 days transactions will be fetched.
     * @param  apikey  Required parameter: This is the API key of the specific environment which
     *         needs to be passed by the client.
     * @param  requestId  Required parameter: Mandatory UUID (according to RFC 4122 standards) for
     *         requests and responses. This will be played back in the response from the request.
     * @param  body  Optional parameter: MultiPayer RequestBody
     * @return    Returns the MultiPricedTransactionResponse response from the API call
     */
    public CompletableFuture<MultiPricedTransactionResponse> multipricedTransactionsAsync(
            final String apikey,
            final String requestId,
            final MultiPricedTransactionRequest body) {
        try { 
            return prepareMultipricedTransactionsRequest(apikey, requestId, body).executeAsync(); 
        } catch (Exception e) {  
            throw new CompletionException(e); 
        }
    }

    /**
     * Builds the ApiCall object for multipricedTransactions.
     */
    private ApiCall<MultiPricedTransactionResponse, ApiException> prepareMultipricedTransactionsRequest(
            final String apikey,
            final String requestId,
            final MultiPricedTransactionRequest body) throws JsonProcessingException, IOException {
        return new ApiCall.Builder<MultiPricedTransactionResponse, ApiException>()
                .globalConfig(getGlobalConfiguration())
                .requestBuilder(requestBuilder -> requestBuilder
                        .server(Server.SHELL.value())
                        .path("/fleetmanagement/v1/transaction/multipayerspricedtransactions")
                        .bodyParam(param -> param.value(body).isRequired(false))
                        .bodySerializer(() ->  ApiHelper.serialize(body))
                        .headerParam(param -> param.key("apikey")
                                .value(apikey).isRequired(false))
                        .headerParam(param -> param.key("RequestId")
                                .value(requestId).isRequired(false))
                        .headerParam(param -> param.key("Content-Type")
                                .value("application/json").isRequired(false))
                        .headerParam(param -> param.key("accept").value("application/json"))
                        .withAuth(auth -> auth
                                .add("BasicAuth"))
                        .httpMethod(HttpMethod.POST))
                .responseHandler(responseHandler -> responseHandler
                        .deserializer(
                                response -> ApiHelper.deserialize(response, MultiPricedTransactionResponse.class))
                        .nullify404(false)
                        .localErrorCase("400",
                                 ErrorCase.setReason("The server cannot or will not process the request  due to something that is perceived to be a client\r\n error (e.g., malformed request syntax, invalid \r\n request message framing, or deceptive request routing).",
                                (reason, context) -> new DefaultErrorException(reason, context)))
                        .localErrorCase("401",
                                 ErrorCase.setReason("The request has not been applied because it lacks valid  authentication credentials for the target resource.\r\n",
                                (reason, context) -> new DefaultErrorException(reason, context)))
                        .localErrorCase("403",
                                 ErrorCase.setReason("The server understood the request but refuses to authorize it.\r\n",
                                (reason, context) -> new ErrorUserAccessError1Exception(reason, context)))
                        .localErrorCase("404",
                                 ErrorCase.setReason("The origin server did not find a current representation  for the target resource or is not willing to disclose  that one exists.\r\n",
                                (reason, context) -> new DefaultErrorException(reason, context)))
                        .localErrorCase("500",
                                 ErrorCase.setReason("The server encountered an unexpected condition the prevented it from fulfilling the request.\r\n",
                                (reason, context) -> new DefaultErrorException(reason, context)))
                        .globalErrorCase(GLOBAL_ERROR_CASES))
                .build();
    }

    /**
     * This operation is to provide the expenditure analysis for a card for the past 7 months. The
     * response contains a daily summary of the transactions (billed &amp; unbilled) from 1st of the
     * last 7 months for the requested card grouped by card, site-group and product.
     * @param  apikey  Required parameter: This is the API key of the specific environment which
     *         needs to be passed by the client.
     * @param  requestId  Required parameter: Mandatory UUID (according to RFC 4122 standards) for
     *         requests and responses. This will be played back in the response from the request.
     * @param  body  Optional parameter: Card Usage Summary RequestBody
     * @return    Returns the CardUsageSummaryResponse response from the API call
     * @throws    ApiException    Represents error response from the server.
     * @throws    IOException    Signals that an I/O exception of some sort has occurred.
     */
    public CardUsageSummaryResponse cardUsageSummary(
            final String apikey,
            final String requestId,
            final CardUsageSummaryRequest body) throws ApiException, IOException {
        return prepareCardUsageSummaryRequest(apikey, requestId, body).execute();
    }

    /**
     * This operation is to provide the expenditure analysis for a card for the past 7 months. The
     * response contains a daily summary of the transactions (billed &amp; unbilled) from 1st of the
     * last 7 months for the requested card grouped by card, site-group and product.
     * @param  apikey  Required parameter: This is the API key of the specific environment which
     *         needs to be passed by the client.
     * @param  requestId  Required parameter: Mandatory UUID (according to RFC 4122 standards) for
     *         requests and responses. This will be played back in the response from the request.
     * @param  body  Optional parameter: Card Usage Summary RequestBody
     * @return    Returns the CardUsageSummaryResponse response from the API call
     */
    public CompletableFuture<CardUsageSummaryResponse> cardUsageSummaryAsync(
            final String apikey,
            final String requestId,
            final CardUsageSummaryRequest body) {
        try { 
            return prepareCardUsageSummaryRequest(apikey, requestId, body).executeAsync(); 
        } catch (Exception e) {  
            throw new CompletionException(e); 
        }
    }

    /**
     * Builds the ApiCall object for cardUsageSummary.
     */
    private ApiCall<CardUsageSummaryResponse, ApiException> prepareCardUsageSummaryRequest(
            final String apikey,
            final String requestId,
            final CardUsageSummaryRequest body) throws JsonProcessingException, IOException {
        return new ApiCall.Builder<CardUsageSummaryResponse, ApiException>()
                .globalConfig(getGlobalConfiguration())
                .requestBuilder(requestBuilder -> requestBuilder
                        .server(Server.SHELL.value())
                        .path("/fleetmanagement/v1/transaction/cardusagesummary")
                        .bodyParam(param -> param.value(body).isRequired(false))
                        .bodySerializer(() ->  ApiHelper.serialize(body))
                        .headerParam(param -> param.key("apikey")
                                .value(apikey).isRequired(false))
                        .headerParam(param -> param.key("RequestId")
                                .value(requestId).isRequired(false))
                        .headerParam(param -> param.key("Content-Type")
                                .value("application/json").isRequired(false))
                        .headerParam(param -> param.key("accept").value("application/json"))
                        .withAuth(auth -> auth
                                .add("BasicAuth"))
                        .httpMethod(HttpMethod.POST))
                .responseHandler(responseHandler -> responseHandler
                        .deserializer(
                                response -> ApiHelper.deserialize(response, CardUsageSummaryResponse.class))
                        .nullify404(false)
                        .localErrorCase("400",
                                 ErrorCase.setReason("The server cannot or will not process the request  due to something that is perceived to be a client\r\n error (e.g., malformed request syntax, invalid \r\n request message framing, or deceptive request routing).",
                                (reason, context) -> new DefaultErrorException(reason, context)))
                        .localErrorCase("401",
                                 ErrorCase.setReason("The request has not been applied because it lacks valid  authentication credentials for the target resource.\r\n",
                                (reason, context) -> new DefaultErrorException(reason, context)))
                        .localErrorCase("403",
                                 ErrorCase.setReason("The server understood the request but refuses to authorize it.\r\n",
                                (reason, context) -> new ErrorUserAccessError1Exception(reason, context)))
                        .localErrorCase("404",
                                 ErrorCase.setReason("The origin server did not find a current representation  for the target resource or is not willing to disclose  that one exists.\r\n",
                                (reason, context) -> new DefaultErrorException(reason, context)))
                        .localErrorCase("500",
                                 ErrorCase.setReason("The server encountered an unexpected condition the prevented it from fulfilling the request.\r\n",
                                (reason, context) -> new DefaultErrorException(reason, context)))
                        .globalErrorCase(GLOBAL_ERROR_CASES))
                .build();
    }

    /**
     * - This API provides the details of the bonus and/or association bonus rules setup for the
     * given payer and that are active on the current date. - This API also returns the details of
     * the monthly breakup of current period consumption as well as the details of the previously
     * calculated bonus and consumption of the applicable payers.
     * @param  apikey  Required parameter: This is the API key of the specific environment which
     *         needs to be passed by the client.
     * @param  requestId  Required parameter: Mandatory UUID (according to RFC 4122 standards) for
     *         requests and responses. This will be played back in the response from the request.
     * @param  body  Optional parameter: VolumeBasedBonus RequestBody
     * @return    Returns the VolumeBasedBonusResponse response from the API call
     * @throws    ApiException    Represents error response from the server.
     * @throws    IOException    Signals that an I/O exception of some sort has occurred.
     */
    public VolumeBasedBonusResponse volumeBasedBonus(
            final String apikey,
            final String requestId,
            final VolumeBasedBonusRequest body) throws ApiException, IOException {
        return prepareVolumeBasedBonusRequest(apikey, requestId, body).execute();
    }

    /**
     * - This API provides the details of the bonus and/or association bonus rules setup for the
     * given payer and that are active on the current date. - This API also returns the details of
     * the monthly breakup of current period consumption as well as the details of the previously
     * calculated bonus and consumption of the applicable payers.
     * @param  apikey  Required parameter: This is the API key of the specific environment which
     *         needs to be passed by the client.
     * @param  requestId  Required parameter: Mandatory UUID (according to RFC 4122 standards) for
     *         requests and responses. This will be played back in the response from the request.
     * @param  body  Optional parameter: VolumeBasedBonus RequestBody
     * @return    Returns the VolumeBasedBonusResponse response from the API call
     */
    public CompletableFuture<VolumeBasedBonusResponse> volumeBasedBonusAsync(
            final String apikey,
            final String requestId,
            final VolumeBasedBonusRequest body) {
        try { 
            return prepareVolumeBasedBonusRequest(apikey, requestId, body).executeAsync(); 
        } catch (Exception e) {  
            throw new CompletionException(e); 
        }
    }

    /**
     * Builds the ApiCall object for volumeBasedBonus.
     */
    private ApiCall<VolumeBasedBonusResponse, ApiException> prepareVolumeBasedBonusRequest(
            final String apikey,
            final String requestId,
            final VolumeBasedBonusRequest body) throws JsonProcessingException, IOException {
        return new ApiCall.Builder<VolumeBasedBonusResponse, ApiException>()
                .globalConfig(getGlobalConfiguration())
                .requestBuilder(requestBuilder -> requestBuilder
                        .server(Server.SHELL.value())
                        .path("/fleetmanagement/v1/transaction/volumebasedbonus")
                        .bodyParam(param -> param.value(body).isRequired(false))
                        .bodySerializer(() ->  ApiHelper.serialize(body))
                        .headerParam(param -> param.key("apikey")
                                .value(apikey).isRequired(false))
                        .headerParam(param -> param.key("RequestId")
                                .value(requestId).isRequired(false))
                        .headerParam(param -> param.key("Content-Type")
                                .value("application/json").isRequired(false))
                        .headerParam(param -> param.key("accept").value("application/json"))
                        .withAuth(auth -> auth
                                .add("BasicAuth"))
                        .httpMethod(HttpMethod.POST))
                .responseHandler(responseHandler -> responseHandler
                        .deserializer(
                                response -> ApiHelper.deserialize(response, VolumeBasedBonusResponse.class))
                        .nullify404(false)
                        .localErrorCase("400",
                                 ErrorCase.setReason("The server cannot or will not process the request  due to something that is perceived to be a client\r\n error (e.g., malformed request syntax, invalid \r\n request message framing, or deceptive request routing).",
                                (reason, context) -> new DefaultErrorException(reason, context)))
                        .localErrorCase("401",
                                 ErrorCase.setReason("The request has not been applied because it lacks valid  authentication credentials for the target resource.\r\n",
                                (reason, context) -> new DefaultErrorException(reason, context)))
                        .localErrorCase("403",
                                 ErrorCase.setReason("The server understood the request but refuses to authorize it.\r\n",
                                (reason, context) -> new ErrorUserAccessError1Exception(reason, context)))
                        .localErrorCase("404",
                                 ErrorCase.setReason("The origin server did not find a current representation  for the target resource or is not willing to disclose  that one exists.\r\n",
                                (reason, context) -> new DefaultErrorException(reason, context)))
                        .localErrorCase("500",
                                 ErrorCase.setReason("The server encountered an unexpected condition the prevented it from fulfilling the request.\r\n",
                                (reason, context) -> new DefaultErrorException(reason, context)))
                        .globalErrorCase(GLOBAL_ERROR_CASES))
                .build();
    }

    /**
     * - This API will return the details of the in arrear fee rule applied to the payer along with
     * details of locations, products, tiers as applied. - It will also show historical and current
     * volume consumption and related tier applied for the following month.
     * @param  apikey  Required parameter: This is the API key of the specific environment which
     *         needs to be passed by the client.
     * @param  requestId  Required parameter: Mandatory UUID (according to RFC 4122 standards) for
     *         requests and responses. This will be played back in the response from the request.
     * @param  body  Optional parameter: VolumeBasedPricing RequestBody
     * @return    Returns the VolumeBasedPricingResponse response from the API call
     * @throws    ApiException    Represents error response from the server.
     * @throws    IOException    Signals that an I/O exception of some sort has occurred.
     */
    public VolumeBasedPricingResponse volumeBasedPricing(
            final String apikey,
            final String requestId,
            final VolumeBasedPricingRequest body) throws ApiException, IOException {
        return prepareVolumeBasedPricingRequest(apikey, requestId, body).execute();
    }

    /**
     * - This API will return the details of the in arrear fee rule applied to the payer along with
     * details of locations, products, tiers as applied. - It will also show historical and current
     * volume consumption and related tier applied for the following month.
     * @param  apikey  Required parameter: This is the API key of the specific environment which
     *         needs to be passed by the client.
     * @param  requestId  Required parameter: Mandatory UUID (according to RFC 4122 standards) for
     *         requests and responses. This will be played back in the response from the request.
     * @param  body  Optional parameter: VolumeBasedPricing RequestBody
     * @return    Returns the VolumeBasedPricingResponse response from the API call
     */
    public CompletableFuture<VolumeBasedPricingResponse> volumeBasedPricingAsync(
            final String apikey,
            final String requestId,
            final VolumeBasedPricingRequest body) {
        try { 
            return prepareVolumeBasedPricingRequest(apikey, requestId, body).executeAsync(); 
        } catch (Exception e) {  
            throw new CompletionException(e); 
        }
    }

    /**
     * Builds the ApiCall object for volumeBasedPricing.
     */
    private ApiCall<VolumeBasedPricingResponse, ApiException> prepareVolumeBasedPricingRequest(
            final String apikey,
            final String requestId,
            final VolumeBasedPricingRequest body) throws JsonProcessingException, IOException {
        return new ApiCall.Builder<VolumeBasedPricingResponse, ApiException>()
                .globalConfig(getGlobalConfiguration())
                .requestBuilder(requestBuilder -> requestBuilder
                        .server(Server.SHELL.value())
                        .path("/fleetmanagement/v1/transaction/volumebasedpricing")
                        .bodyParam(param -> param.value(body).isRequired(false))
                        .bodySerializer(() ->  ApiHelper.serialize(body))
                        .headerParam(param -> param.key("apikey")
                                .value(apikey).isRequired(false))
                        .headerParam(param -> param.key("RequestId")
                                .value(requestId).isRequired(false))
                        .headerParam(param -> param.key("Content-Type")
                                .value("application/json").isRequired(false))
                        .headerParam(param -> param.key("accept").value("application/json"))
                        .withAuth(auth -> auth
                                .add("BasicAuth"))
                        .httpMethod(HttpMethod.POST))
                .responseHandler(responseHandler -> responseHandler
                        .deserializer(
                                response -> ApiHelper.deserialize(response, VolumeBasedPricingResponse.class))
                        .nullify404(false)
                        .localErrorCase("400",
                                 ErrorCase.setReason("The server cannot or will not process the request  due to something that is perceived to be a client\r\n error (e.g., malformed request syntax, invalid \r\n request message framing, or deceptive request routing).",
                                (reason, context) -> new DefaultErrorException(reason, context)))
                        .localErrorCase("401",
                                 ErrorCase.setReason("The request has not been applied because it lacks valid  authentication credentials for the target resource.\r\n",
                                (reason, context) -> new DefaultErrorException(reason, context)))
                        .localErrorCase("403",
                                 ErrorCase.setReason("The server understood the request but refuses to authorize it.\r\n",
                                (reason, context) -> new ErrorUserAccessError1Exception(reason, context)))
                        .localErrorCase("404",
                                 ErrorCase.setReason("The origin server did not find a current representation  for the target resource or is not willing to disclose  that one exists.\r\n",
                                (reason, context) -> new DefaultErrorException(reason, context)))
                        .localErrorCase("500",
                                 ErrorCase.setReason("The server encountered an unexpected condition the prevented it from fulfilling the request.\r\n",
                                (reason, context) -> new DefaultErrorException(reason, context)))
                        .globalErrorCase(GLOBAL_ERROR_CASES))
                .build();
    }

    /**
     * This API returns the fee/charges levied from a customer's account in a billing period or date
     * range. The API returns both billed and unbilled fee items. To get the summary of charges, the
     * endpoint *transaction/feessummary* should be called with the same input criteria. ####
     * Supported operations * Get fees by invoice status * Get fees by date period * Get fees by
     * account * Get fees by card Id or PAN * Get fees by fee type charges * Get fees including
     * cancelled items * Get fees by line item description * Get fees by product.
     * @param  apikey  Required parameter: This is the API key of the specific environment which
     *         needs to be passed by the client.
     * @param  requestId  Required parameter: Mandatory UUID (according to RFC 4122 standards) for
     *         requests and responses. This will be played back in the response from the request.
     * @param  body  Optional parameter: Transaction Fees RequestBody
     * @return    Returns the TransactionFeesResponse response from the API call
     * @throws    ApiException    Represents error response from the server.
     * @throws    IOException    Signals that an I/O exception of some sort has occurred.
     */
    public TransactionFeesResponse fees(
            final String apikey,
            final String requestId,
            final TransactionFeesRequest body) throws ApiException, IOException {
        return prepareFeesRequest(apikey, requestId, body).execute();
    }

    /**
     * This API returns the fee/charges levied from a customer's account in a billing period or date
     * range. The API returns both billed and unbilled fee items. To get the summary of charges, the
     * endpoint *transaction/feessummary* should be called with the same input criteria. ####
     * Supported operations * Get fees by invoice status * Get fees by date period * Get fees by
     * account * Get fees by card Id or PAN * Get fees by fee type charges * Get fees including
     * cancelled items * Get fees by line item description * Get fees by product.
     * @param  apikey  Required parameter: This is the API key of the specific environment which
     *         needs to be passed by the client.
     * @param  requestId  Required parameter: Mandatory UUID (according to RFC 4122 standards) for
     *         requests and responses. This will be played back in the response from the request.
     * @param  body  Optional parameter: Transaction Fees RequestBody
     * @return    Returns the TransactionFeesResponse response from the API call
     */
    public CompletableFuture<TransactionFeesResponse> feesAsync(
            final String apikey,
            final String requestId,
            final TransactionFeesRequest body) {
        try { 
            return prepareFeesRequest(apikey, requestId, body).executeAsync(); 
        } catch (Exception e) {  
            throw new CompletionException(e); 
        }
    }

    /**
     * Builds the ApiCall object for fees.
     */
    private ApiCall<TransactionFeesResponse, ApiException> prepareFeesRequest(
            final String apikey,
            final String requestId,
            final TransactionFeesRequest body) throws JsonProcessingException, IOException {
        return new ApiCall.Builder<TransactionFeesResponse, ApiException>()
                .globalConfig(getGlobalConfiguration())
                .requestBuilder(requestBuilder -> requestBuilder
                        .server(Server.SHELL.value())
                        .path("/fleetmanagement/v1/transaction/fees")
                        .bodyParam(param -> param.value(body).isRequired(false))
                        .bodySerializer(() ->  ApiHelper.serialize(body))
                        .headerParam(param -> param.key("apikey")
                                .value(apikey).isRequired(false))
                        .headerParam(param -> param.key("RequestId")
                                .value(requestId).isRequired(false))
                        .headerParam(param -> param.key("Content-Type")
                                .value("application/json").isRequired(false))
                        .headerParam(param -> param.key("accept").value("application/json"))
                        .withAuth(auth -> auth
                                .add("BasicAuth"))
                        .httpMethod(HttpMethod.POST))
                .responseHandler(responseHandler -> responseHandler
                        .deserializer(
                                response -> ApiHelper.deserialize(response, TransactionFeesResponse.class))
                        .nullify404(false)
                        .localErrorCase("400",
                                 ErrorCase.setReason("The server cannot or will not process the request  due to something that is perceived to be a client\r\n error (e.g., malformed request syntax, invalid \r\n request message framing, or deceptive request routing).",
                                (reason, context) -> new DefaultErrorException(reason, context)))
                        .localErrorCase("401",
                                 ErrorCase.setReason("The request has not been applied because it lacks valid  authentication credentials for the target resource.\r\n",
                                (reason, context) -> new DefaultErrorException(reason, context)))
                        .localErrorCase("403",
                                 ErrorCase.setReason("The server understood the request but refuses to authorize it.\r\n",
                                (reason, context) -> new ErrorUserAccessError1Exception(reason, context)))
                        .localErrorCase("404",
                                 ErrorCase.setReason("The origin server did not find a current representation  for the target resource or is not willing to disclose  that one exists.\r\n",
                                (reason, context) -> new DefaultErrorException(reason, context)))
                        .localErrorCase("500",
                                 ErrorCase.setReason("The server encountered an unexpected condition the prevented it from fulfilling the request.\r\n",
                                (reason, context) -> new DefaultErrorException(reason, context)))
                        .globalErrorCase(GLOBAL_ERROR_CASES))
                .build();
    }

    /**
     * This API returns the summary data of the fee/charges levied from a customer's account in a
     * billing period or date range. The API returns both billed and unbilled fee items. The
     * endpoint supports the exact same search criteria as the endpoint *transaction/feessummary*.
     * #### Supported operations * Get fees by invoice status * Get fees by date period * Get fees
     * by account * Get fees by card Id or PAN * Get fees by fee type charges * Get fees including
     * cancelled items * Get fees by line item description * Get fees by product.
     * @param  apikey  Required parameter: This is the API key of the specific environment which
     *         needs to be passed by the client.
     * @param  requestId  Required parameter: Mandatory UUID (according to RFC 4122 standards) for
     *         requests and responses. This will be played back in the response from the request.
     * @param  body  Optional parameter: FeeSummary RequestBody
     * @return    Returns the FeeSummaryResponse response from the API call
     * @throws    ApiException    Represents error response from the server.
     * @throws    IOException    Signals that an I/O exception of some sort has occurred.
     */
    public FeeSummaryResponse feeSummaryResponse(
            final String apikey,
            final String requestId,
            final TransactionFeesRequest body) throws ApiException, IOException {
        return prepareFeeSummaryResponseRequest(apikey, requestId, body).execute();
    }

    /**
     * This API returns the summary data of the fee/charges levied from a customer's account in a
     * billing period or date range. The API returns both billed and unbilled fee items. The
     * endpoint supports the exact same search criteria as the endpoint *transaction/feessummary*.
     * #### Supported operations * Get fees by invoice status * Get fees by date period * Get fees
     * by account * Get fees by card Id or PAN * Get fees by fee type charges * Get fees including
     * cancelled items * Get fees by line item description * Get fees by product.
     * @param  apikey  Required parameter: This is the API key of the specific environment which
     *         needs to be passed by the client.
     * @param  requestId  Required parameter: Mandatory UUID (according to RFC 4122 standards) for
     *         requests and responses. This will be played back in the response from the request.
     * @param  body  Optional parameter: FeeSummary RequestBody
     * @return    Returns the FeeSummaryResponse response from the API call
     */
    public CompletableFuture<FeeSummaryResponse> feeSummaryResponseAsync(
            final String apikey,
            final String requestId,
            final TransactionFeesRequest body) {
        try { 
            return prepareFeeSummaryResponseRequest(apikey, requestId, body).executeAsync(); 
        } catch (Exception e) {  
            throw new CompletionException(e); 
        }
    }

    /**
     * Builds the ApiCall object for feeSummaryResponse.
     */
    private ApiCall<FeeSummaryResponse, ApiException> prepareFeeSummaryResponseRequest(
            final String apikey,
            final String requestId,
            final TransactionFeesRequest body) throws JsonProcessingException, IOException {
        return new ApiCall.Builder<FeeSummaryResponse, ApiException>()
                .globalConfig(getGlobalConfiguration())
                .requestBuilder(requestBuilder -> requestBuilder
                        .server(Server.SHELL.value())
                        .path("/fleetmanagement/v1/transaction/feessummary")
                        .bodyParam(param -> param.value(body).isRequired(false))
                        .bodySerializer(() ->  ApiHelper.serialize(body))
                        .headerParam(param -> param.key("apikey")
                                .value(apikey).isRequired(false))
                        .headerParam(param -> param.key("RequestId")
                                .value(requestId).isRequired(false))
                        .headerParam(param -> param.key("Content-Type")
                                .value("application/json").isRequired(false))
                        .headerParam(param -> param.key("accept").value("application/json"))
                        .withAuth(auth -> auth
                                .add("BasicAuth"))
                        .httpMethod(HttpMethod.POST))
                .responseHandler(responseHandler -> responseHandler
                        .deserializer(
                                response -> ApiHelper.deserialize(response, FeeSummaryResponse.class))
                        .nullify404(false)
                        .localErrorCase("400",
                                 ErrorCase.setReason("The server cannot or will not process the request  due to something that is perceived to be a client\r\n error (e.g., malformed request syntax, invalid \r\n request message framing, or deceptive request routing).",
                                (reason, context) -> new DefaultErrorException(reason, context)))
                        .localErrorCase("401",
                                 ErrorCase.setReason("The request has not been applied because it lacks valid  authentication credentials for the target resource.\r\n",
                                (reason, context) -> new DefaultErrorException(reason, context)))
                        .localErrorCase("403",
                                 ErrorCase.setReason("The server understood the request but refuses to authorize it.\r\n",
                                (reason, context) -> new ErrorUserAccessError1Exception(reason, context)))
                        .localErrorCase("404",
                                 ErrorCase.setReason("The origin server did not find a current representation  for the target resource or is not willing to disclose  that one exists.\r\n",
                                (reason, context) -> new DefaultErrorException(reason, context)))
                        .localErrorCase("500",
                                 ErrorCase.setReason("The server encountered an unexpected condition the prevented it from fulfilling the request.\r\n",
                                (reason, context) -> new DefaultErrorException(reason, context)))
                        .globalErrorCase(GLOBAL_ERROR_CASES))
                .build();
    }

    /**
     * - This API returns the customer an overview of how many transactions, how much fuel volume
     * used over a given period and the total volume used by a card - This operation response will
     * contains card &amp; transaction details for given period aggregated by payer, account, cardGroup,
     * PAN, DriverName and VRN.
     * @param  apikey  Required parameter: This is the API key of the specific environment which
     *         needs to be passed by the client.
     * @param  requestId  Required parameter: Mandatory UUID (according to RFC 4122 standards) for
     *         requests and responses. This will be played back in the response from the request.
     * @param  body  Optional parameter: FuelConsumption RequestBody
     * @return    Returns the FuelConsumptionResponse response from the API call
     * @throws    ApiException    Represents error response from the server.
     * @throws    IOException    Signals that an I/O exception of some sort has occurred.
     */
    public FuelConsumptionResponse fuelConsumption(
            final String apikey,
            final String requestId,
            final FuelConsumptionRequest body) throws ApiException, IOException {
        return prepareFuelConsumptionRequest(apikey, requestId, body).execute();
    }

    /**
     * - This API returns the customer an overview of how many transactions, how much fuel volume
     * used over a given period and the total volume used by a card - This operation response will
     * contains card &amp; transaction details for given period aggregated by payer, account, cardGroup,
     * PAN, DriverName and VRN.
     * @param  apikey  Required parameter: This is the API key of the specific environment which
     *         needs to be passed by the client.
     * @param  requestId  Required parameter: Mandatory UUID (according to RFC 4122 standards) for
     *         requests and responses. This will be played back in the response from the request.
     * @param  body  Optional parameter: FuelConsumption RequestBody
     * @return    Returns the FuelConsumptionResponse response from the API call
     */
    public CompletableFuture<FuelConsumptionResponse> fuelConsumptionAsync(
            final String apikey,
            final String requestId,
            final FuelConsumptionRequest body) {
        try { 
            return prepareFuelConsumptionRequest(apikey, requestId, body).executeAsync(); 
        } catch (Exception e) {  
            throw new CompletionException(e); 
        }
    }

    /**
     * Builds the ApiCall object for fuelConsumption.
     */
    private ApiCall<FuelConsumptionResponse, ApiException> prepareFuelConsumptionRequest(
            final String apikey,
            final String requestId,
            final FuelConsumptionRequest body) throws JsonProcessingException, IOException {
        return new ApiCall.Builder<FuelConsumptionResponse, ApiException>()
                .globalConfig(getGlobalConfiguration())
                .requestBuilder(requestBuilder -> requestBuilder
                        .server(Server.SHELL.value())
                        .path("/fleetmanagement/v1/transaction/fuelconsumption")
                        .bodyParam(param -> param.value(body).isRequired(false))
                        .bodySerializer(() ->  ApiHelper.serialize(body))
                        .headerParam(param -> param.key("apikey")
                                .value(apikey).isRequired(false))
                        .headerParam(param -> param.key("RequestId")
                                .value(requestId).isRequired(false))
                        .headerParam(param -> param.key("Content-Type")
                                .value("application/json").isRequired(false))
                        .headerParam(param -> param.key("accept").value("application/json"))
                        .withAuth(auth -> auth
                                .add("BasicAuth"))
                        .httpMethod(HttpMethod.POST))
                .responseHandler(responseHandler -> responseHandler
                        .deserializer(
                                response -> ApiHelper.deserialize(response, FuelConsumptionResponse.class))
                        .nullify404(false)
                        .localErrorCase("400",
                                 ErrorCase.setReason("The server cannot or will not process the request  due to something that is perceived to be a client\r\n error (e.g., malformed request syntax, invalid \r\n request message framing, or deceptive request routing).",
                                (reason, context) -> new DefaultErrorException(reason, context)))
                        .localErrorCase("401",
                                 ErrorCase.setReason("The request has not been applied because it lacks valid  authentication credentials for the target resource.\r\n",
                                (reason, context) -> new DefaultErrorException(reason, context)))
                        .localErrorCase("403",
                                 ErrorCase.setReason("The server understood the request but refuses to authorize it.\r\n",
                                (reason, context) -> new ErrorUserAccessError1Exception(reason, context)))
                        .localErrorCase("404",
                                 ErrorCase.setReason("The origin server did not find a current representation  for the target resource or is not willing to disclose  that one exists.\r\n",
                                (reason, context) -> new DefaultErrorException(reason, context)))
                        .localErrorCase("500",
                                 ErrorCase.setReason("The server encountered an unexpected condition the prevented it from fulfilling the request.\r\n",
                                (reason, context) -> new DefaultErrorException(reason, context)))
                        .globalErrorCase(GLOBAL_ERROR_CASES))
                .build();
    }

    /**
     * - This API allows the users to update the odometer readings on the sales items (transaction
     * data) - This is an asynchronous operation. If opted, the user will be notified on completion
     * of processing.
     * @param  apikey  Required parameter: This is the API key of the specific environment which
     *         needs to be passed by the client.
     * @param  requestId  Required parameter: Mandatory UUID (according to RFC 4122 standards) for
     *         requests and responses. This will be played back in the response from the request.
     * @param  body  Optional parameter: updateOdometer RequestBody
     * @return    Returns the UpdateOdometerResponse response from the API call
     * @throws    ApiException    Represents error response from the server.
     * @throws    IOException    Signals that an I/O exception of some sort has occurred.
     */
    public UpdateOdometerResponse updateOdometer(
            final String apikey,
            final String requestId,
            final UpdateOdometerRequest body) throws ApiException, IOException {
        return prepareUpdateOdometerRequest(apikey, requestId, body).execute();
    }

    /**
     * - This API allows the users to update the odometer readings on the sales items (transaction
     * data) - This is an asynchronous operation. If opted, the user will be notified on completion
     * of processing.
     * @param  apikey  Required parameter: This is the API key of the specific environment which
     *         needs to be passed by the client.
     * @param  requestId  Required parameter: Mandatory UUID (according to RFC 4122 standards) for
     *         requests and responses. This will be played back in the response from the request.
     * @param  body  Optional parameter: updateOdometer RequestBody
     * @return    Returns the UpdateOdometerResponse response from the API call
     */
    public CompletableFuture<UpdateOdometerResponse> updateOdometerAsync(
            final String apikey,
            final String requestId,
            final UpdateOdometerRequest body) {
        try { 
            return prepareUpdateOdometerRequest(apikey, requestId, body).executeAsync(); 
        } catch (Exception e) {  
            throw new CompletionException(e); 
        }
    }

    /**
     * Builds the ApiCall object for updateOdometer.
     */
    private ApiCall<UpdateOdometerResponse, ApiException> prepareUpdateOdometerRequest(
            final String apikey,
            final String requestId,
            final UpdateOdometerRequest body) throws JsonProcessingException, IOException {
        return new ApiCall.Builder<UpdateOdometerResponse, ApiException>()
                .globalConfig(getGlobalConfiguration())
                .requestBuilder(requestBuilder -> requestBuilder
                        .server(Server.SHELL.value())
                        .path("/fleetmanagement/v1/transaction/updateodometer")
                        .bodyParam(param -> param.value(body).isRequired(false))
                        .bodySerializer(() ->  ApiHelper.serialize(body))
                        .headerParam(param -> param.key("apikey")
                                .value(apikey).isRequired(false))
                        .headerParam(param -> param.key("RequestId")
                                .value(requestId).isRequired(false))
                        .headerParam(param -> param.key("Content-Type")
                                .value("application/json").isRequired(false))
                        .headerParam(param -> param.key("accept").value("application/json"))
                        .withAuth(auth -> auth
                                .add("BasicAuth"))
                        .httpMethod(HttpMethod.POST))
                .responseHandler(responseHandler -> responseHandler
                        .deserializer(
                                response -> ApiHelper.deserialize(response, UpdateOdometerResponse.class))
                        .nullify404(false)
                        .localErrorCase("400",
                                 ErrorCase.setReason("The server cannot or will not process the request  due to something that is perceived to be a client\r\n error (e.g., malformed request syntax, invalid \r\n request message framing, or deceptive request routing).",
                                (reason, context) -> new DefaultErrorException(reason, context)))
                        .localErrorCase("401",
                                 ErrorCase.setReason("The request has not been applied because it lacks valid  authentication credentials for the target resource.\r\n",
                                (reason, context) -> new DefaultErrorException(reason, context)))
                        .localErrorCase("403",
                                 ErrorCase.setReason("The server understood the request but refuses to authorize it.\r\n",
                                (reason, context) -> new ErrorUserAccessError1Exception(reason, context)))
                        .localErrorCase("404",
                                 ErrorCase.setReason("The origin server did not find a current representation  for the target resource or is not willing to disclose  that one exists.\r\n",
                                (reason, context) -> new DefaultErrorException(reason, context)))
                        .localErrorCase("500",
                                 ErrorCase.setReason("The server encountered an unexpected condition the prevented it from fulfilling the request.\r\n",
                                (reason, context) -> new DefaultErrorException(reason, context)))
                        .globalErrorCase(GLOBAL_ERROR_CASES))
                .build();
    }

    /**
     * - This API provides the details of the Cards or Transaction related exceptions based on the
     * given conditions for the Requested period. - This API will return the Transactions related
     * exceptions when the OutputType input parameter is passed as ‘Transaction’ else will return
     * the Cards related exceptions.
     * @param  apikey  Required parameter: This is the API key of the specific environment which
     *         needs to be passed by the client.
     * @param  requestId  Required parameter: Mandatory UUID (according to RFC 4122 standards) for
     *         requests and responses. This will be played back in the response from the request.
     * @param  body  Optional parameter: Transaction Exceptions RequestBody
     * @return    Returns the TransactionExceptionsResponse response from the API call
     * @throws    ApiException    Represents error response from the server.
     * @throws    IOException    Signals that an I/O exception of some sort has occurred.
     */
    public TransactionExceptionsResponse transactionExceptions(
            final String apikey,
            final String requestId,
            final TransactionExceptionsRequest body) throws ApiException, IOException {
        return prepareTransactionExceptionsRequest(apikey, requestId, body).execute();
    }

    /**
     * - This API provides the details of the Cards or Transaction related exceptions based on the
     * given conditions for the Requested period. - This API will return the Transactions related
     * exceptions when the OutputType input parameter is passed as ‘Transaction’ else will return
     * the Cards related exceptions.
     * @param  apikey  Required parameter: This is the API key of the specific environment which
     *         needs to be passed by the client.
     * @param  requestId  Required parameter: Mandatory UUID (according to RFC 4122 standards) for
     *         requests and responses. This will be played back in the response from the request.
     * @param  body  Optional parameter: Transaction Exceptions RequestBody
     * @return    Returns the TransactionExceptionsResponse response from the API call
     */
    public CompletableFuture<TransactionExceptionsResponse> transactionExceptionsAsync(
            final String apikey,
            final String requestId,
            final TransactionExceptionsRequest body) {
        try { 
            return prepareTransactionExceptionsRequest(apikey, requestId, body).executeAsync(); 
        } catch (Exception e) {  
            throw new CompletionException(e); 
        }
    }

    /**
     * Builds the ApiCall object for transactionExceptions.
     */
    private ApiCall<TransactionExceptionsResponse, ApiException> prepareTransactionExceptionsRequest(
            final String apikey,
            final String requestId,
            final TransactionExceptionsRequest body) throws JsonProcessingException, IOException {
        return new ApiCall.Builder<TransactionExceptionsResponse, ApiException>()
                .globalConfig(getGlobalConfiguration())
                .requestBuilder(requestBuilder -> requestBuilder
                        .server(Server.SHELL.value())
                        .path("/fleetmanagement/v1/transaction/exceptions")
                        .bodyParam(param -> param.value(body).isRequired(false))
                        .bodySerializer(() ->  ApiHelper.serialize(body))
                        .headerParam(param -> param.key("apikey")
                                .value(apikey).isRequired(false))
                        .headerParam(param -> param.key("RequestId")
                                .value(requestId).isRequired(false))
                        .headerParam(param -> param.key("Content-Type")
                                .value("application/json").isRequired(false))
                        .headerParam(param -> param.key("accept").value("application/json"))
                        .withAuth(auth -> auth
                                .add("BasicAuth"))
                        .httpMethod(HttpMethod.POST))
                .responseHandler(responseHandler -> responseHandler
                        .deserializer(
                                response -> ApiHelper.deserialize(response, TransactionExceptionsResponse.class))
                        .nullify404(false)
                        .localErrorCase("400",
                                 ErrorCase.setReason("The server cannot or will not process the request  due to something that is perceived to be a client\r\n error (e.g., malformed request syntax, invalid \r\n request message framing, or deceptive request routing).",
                                (reason, context) -> new DefaultErrorException(reason, context)))
                        .localErrorCase("401",
                                 ErrorCase.setReason("The request has not been applied because it lacks valid  authentication credentials for the target resource.\r\n",
                                (reason, context) -> new DefaultErrorException(reason, context)))
                        .localErrorCase("403",
                                 ErrorCase.setReason("The server understood the request but refuses to authorize it.\r\n",
                                (reason, context) -> new ErrorUserAccessError1Exception(reason, context)))
                        .localErrorCase("404",
                                 ErrorCase.setReason("The origin server did not find a current representation  for the target resource or is not willing to disclose  that one exists.\r\n",
                                (reason, context) -> new DefaultErrorException(reason, context)))
                        .localErrorCase("500",
                                 ErrorCase.setReason("The server encountered an unexpected condition the prevented it from fulfilling the request.\r\n",
                                (reason, context) -> new DefaultErrorException(reason, context)))
                        .globalErrorCase(GLOBAL_ERROR_CASES))
                .build();
    }

    /**
     * This endpoint allows querying last 48 hours of transaction data of Shell Card (i.e. Priced,
     * Billed, Unbilled etc. sales items). It provides a flexible search criteria and supports
     * pagination. E.g., if the request is made at 08:30 AM on 18 Aug 2022 then transactions until
     * 16 Aug 2022 08:30 AM (including) can be retrieved. #### Supported operations * Search by Date
     * and Time range (within the last 48 hours only) * Search by Payer and/or Account number *
     * Search by Card * Search by Purchased Country * Search by Transaction posting date * Search by
     * Driver Name or Vehicle registration number * Search by Fuel only transactions * Search by
     * Product and/or Product group.
     * @param  requestId  Required parameter: Mandatory UUID (according to RFC 4122 standards) for
     *         requests and responses. This will be played back in the response from the request.
     * @param  body  Optional parameter: New Recent Transaction RequestBody
     * @return    Returns the RecentTransactionsResponse response from the API call
     * @throws    ApiException    Represents error response from the server.
     * @throws    IOException    Signals that an I/O exception of some sort has occurred.
     */
    public RecentTransactionsResponse recentTransactionsNew(
            final String requestId,
            final RecentTransactionRequest body) throws ApiException, IOException {
        return prepareRecentTransactionsNewRequest(requestId, body).execute();
    }

    /**
     * This endpoint allows querying last 48 hours of transaction data of Shell Card (i.e. Priced,
     * Billed, Unbilled etc. sales items). It provides a flexible search criteria and supports
     * pagination. E.g., if the request is made at 08:30 AM on 18 Aug 2022 then transactions until
     * 16 Aug 2022 08:30 AM (including) can be retrieved. #### Supported operations * Search by Date
     * and Time range (within the last 48 hours only) * Search by Payer and/or Account number *
     * Search by Card * Search by Purchased Country * Search by Transaction posting date * Search by
     * Driver Name or Vehicle registration number * Search by Fuel only transactions * Search by
     * Product and/or Product group.
     * @param  requestId  Required parameter: Mandatory UUID (according to RFC 4122 standards) for
     *         requests and responses. This will be played back in the response from the request.
     * @param  body  Optional parameter: New Recent Transaction RequestBody
     * @return    Returns the RecentTransactionsResponse response from the API call
     */
    public CompletableFuture<RecentTransactionsResponse> recentTransactionsNewAsync(
            final String requestId,
            final RecentTransactionRequest body) {
        try { 
            return prepareRecentTransactionsNewRequest(requestId, body).executeAsync(); 
        } catch (Exception e) {  
            throw new CompletionException(e); 
        }
    }

    /**
     * Builds the ApiCall object for recentTransactionsNew.
     */
    private ApiCall<RecentTransactionsResponse, ApiException> prepareRecentTransactionsNewRequest(
            final String requestId,
            final RecentTransactionRequest body) throws JsonProcessingException, IOException {
        return new ApiCall.Builder<RecentTransactionsResponse, ApiException>()
                .globalConfig(getGlobalConfiguration())
                .requestBuilder(requestBuilder -> requestBuilder
                        .server(Server.SHELL.value())
                        .path("/transaction-data/v1/recent")
                        .bodyParam(param -> param.value(body).isRequired(false))
                        .bodySerializer(() ->  ApiHelper.serialize(body))
                        .headerParam(param -> param.key("RequestId")
                                .value(requestId).isRequired(false))
                        .headerParam(param -> param.key("Content-Type")
                                .value("application/json").isRequired(false))
                        .headerParam(param -> param.key("accept").value("application/json"))
                        .withAuth(auth -> auth
                                .add("BearerToken"))
                        .httpMethod(HttpMethod.POST))
                .responseHandler(responseHandler -> responseHandler
                        .deserializer(
                                response -> ApiHelper.deserialize(response, RecentTransactionsResponse.class))
                        .nullify404(false)
                        .localErrorCase("400",
                                 ErrorCase.setReason("The server cannot or will not process the request due to something that is perceived to be a client error (e.g., malformed request syntax, invalid request message framing, or deceptive request routing).\n",
                                (reason, context) -> new ErrorObjectException(reason, context)))
                        .localErrorCase("401",
                                 ErrorCase.setReason("The request has not been applied because it lacks valid  authentication credentials for the target resource.\n",
                                (reason, context) -> new ErrorObjectException(reason, context)))
                        .localErrorCase("403",
                                 ErrorCase.setReason("Forbidden",
                                (reason, context) -> new ErrorObjectException(reason, context)))
                        .localErrorCase("404",
                                 ErrorCase.setReason("The origin server did not find a current representation  for the target resource or is not willing to disclose  that one exists.\n",
                                (reason, context) -> new ErrorObjectException(reason, context)))
                        .localErrorCase("500",
                                 ErrorCase.setReason("The server encountered an unexpected condition that  prevented it from fulfilling the request.\n",
                                (reason, context) -> new ErrorObjectException(reason, context)))
                        .globalErrorCase(GLOBAL_ERROR_CASES))
                .build();
    }

    /**
     * This API allows querying transaction data (i.e. Priced, Billed and Unbilled sales items). It
     * provides a flexible search criteria and supports paging. The version 2 is an enhancement to
     * the version 1 where EV transactions and their details are added in the response. Transactions
     * that are posted but not yet priced, billed or that are in error will not be returned by this
     * API. The API also supports returning Fee Items. #### Supported operations * Get sales items
     * and fee transactions * Search by invoice status * Search by fixed date period * Search by
     * date range * Search by account * Search by card * Get sales items only * Search by
     * transaction Id or location * Search by transaction posting date * Search by invoice number or
     * date * Search by driver name or vehicle registration number * Search by card group * Search
     * by fuel only transactions * Search by product * EV transaction details - Below are EV
     * specific parameters * EVOperator * EVSerialId * EVChargePointSerial *
     * EVChargePointConnectorType * EVChargePointConnectorTypeDescription * EVChargeDuration *
     * EVChargeStartDate * EVChargeStartTime * EVChargeEndDate * EVChargeEndTime.
     * @param  requestId  Required parameter: Mandatory UUID (according to RFC 4122 standards) for
     *         requests and responses. This will be played back in the response from the request.
     * @param  body  Optional parameter: Priced TransactionV2 RequestBody
     * @return    Returns the PricedTransactionResponseV2 response from the API call
     * @throws    ApiException    Represents error response from the server.
     * @throws    IOException    Signals that an I/O exception of some sort has occurred.
     */
    public PricedTransactionResponseV2 pricedTransactionsV2(
            final String requestId,
            final PricedTransactionRequestV2 body) throws ApiException, IOException {
        return preparePricedTransactionsV2Request(requestId, body).execute();
    }

    /**
     * This API allows querying transaction data (i.e. Priced, Billed and Unbilled sales items). It
     * provides a flexible search criteria and supports paging. The version 2 is an enhancement to
     * the version 1 where EV transactions and their details are added in the response. Transactions
     * that are posted but not yet priced, billed or that are in error will not be returned by this
     * API. The API also supports returning Fee Items. #### Supported operations * Get sales items
     * and fee transactions * Search by invoice status * Search by fixed date period * Search by
     * date range * Search by account * Search by card * Get sales items only * Search by
     * transaction Id or location * Search by transaction posting date * Search by invoice number or
     * date * Search by driver name or vehicle registration number * Search by card group * Search
     * by fuel only transactions * Search by product * EV transaction details - Below are EV
     * specific parameters * EVOperator * EVSerialId * EVChargePointSerial *
     * EVChargePointConnectorType * EVChargePointConnectorTypeDescription * EVChargeDuration *
     * EVChargeStartDate * EVChargeStartTime * EVChargeEndDate * EVChargeEndTime.
     * @param  requestId  Required parameter: Mandatory UUID (according to RFC 4122 standards) for
     *         requests and responses. This will be played back in the response from the request.
     * @param  body  Optional parameter: Priced TransactionV2 RequestBody
     * @return    Returns the PricedTransactionResponseV2 response from the API call
     */
    public CompletableFuture<PricedTransactionResponseV2> pricedTransactionsV2Async(
            final String requestId,
            final PricedTransactionRequestV2 body) {
        try { 
            return preparePricedTransactionsV2Request(requestId, body).executeAsync(); 
        } catch (Exception e) {  
            throw new CompletionException(e); 
        }
    }

    /**
     * Builds the ApiCall object for pricedTransactionsV2.
     */
    private ApiCall<PricedTransactionResponseV2, ApiException> preparePricedTransactionsV2Request(
            final String requestId,
            final PricedTransactionRequestV2 body) throws JsonProcessingException, IOException {
        return new ApiCall.Builder<PricedTransactionResponseV2, ApiException>()
                .globalConfig(getGlobalConfiguration())
                .requestBuilder(requestBuilder -> requestBuilder
                        .server(Server.SHELL.value())
                        .path("/transaction-data/v1/priced")
                        .bodyParam(param -> param.value(body).isRequired(false))
                        .bodySerializer(() ->  ApiHelper.serialize(body))
                        .headerParam(param -> param.key("RequestId")
                                .value(requestId).isRequired(false))
                        .headerParam(param -> param.key("Content-Type")
                                .value("application/json").isRequired(false))
                        .headerParam(param -> param.key("accept").value("application/json"))
                        .withAuth(auth -> auth
                                .add("BearerToken"))
                        .httpMethod(HttpMethod.POST))
                .responseHandler(responseHandler -> responseHandler
                        .deserializer(
                                response -> ApiHelper.deserialize(response, PricedTransactionResponseV2.class))
                        .nullify404(false)
                        .localErrorCase("400",
                                 ErrorCase.setReason("The server cannot or will not process the request due to something that is perceived to be a client error (e.g., malformed request syntax, invalid request message framing, or deceptive request routing).\n",
                                (reason, context) -> new ErrorObjectException(reason, context)))
                        .localErrorCase("401",
                                 ErrorCase.setReason("The request has not been applied because it lacks valid  authentication credentials for the target resource.\n",
                                (reason, context) -> new ErrorObjectException(reason, context)))
                        .localErrorCase("403",
                                 ErrorCase.setReason("Forbidden",
                                (reason, context) -> new ErrorObjectException(reason, context)))
                        .localErrorCase("404",
                                 ErrorCase.setReason("The origin server did not find a current representation  for the target resource or is not willing to disclose  that one exists.\n",
                                (reason, context) -> new ErrorObjectException(reason, context)))
                        .localErrorCase("500",
                                 ErrorCase.setReason("The server encountered an unexpected condition that  prevented it from fulfilling the request.\n",
                                (reason, context) -> new ErrorObjectException(reason, context)))
                        .globalErrorCase(GLOBAL_ERROR_CASES))
                .build();
    }
}