/*
 * ShellDataReportingAPIsLib
 *
 * This file was automatically generated by APIMATIC v3.0 ( https://www.apimatic.io ).
 */

package com.shell.apitest.controllers;

import com.fasterxml.jackson.core.JsonProcessingException;
import com.shell.apitest.ApiHelper;
import com.shell.apitest.Server;
import com.shell.apitest.exceptions.ApiException;
import com.shell.apitest.exceptions.DefaultErrorException;
import com.shell.apitest.exceptions.ErrorUserAccessError1Exception;
import com.shell.apitest.http.request.HttpMethod;
import com.shell.apitest.models.AccountRequest;
import com.shell.apitest.models.AccountResponse;
import com.shell.apitest.models.AuditRequest;
import com.shell.apitest.models.AuditResponse;
import com.shell.apitest.models.CardGroupRequest;
import com.shell.apitest.models.CardGroupResponse;
import com.shell.apitest.models.CardTypeRequest;
import com.shell.apitest.models.CardTypeResponse;
import com.shell.apitest.models.CustomerDetailRequest;
import com.shell.apitest.models.CustomerDetailResponse;
import com.shell.apitest.models.CustomerPriceListRequest;
import com.shell.apitest.models.CustomerPriceListResponse;
import com.shell.apitest.models.LoggedInUserRequest;
import com.shell.apitest.models.LoggedInUserResponse;
import com.shell.apitest.models.PayerRequest;
import com.shell.apitest.models.PayerResponse;
import io.apimatic.core.ApiCall;
import io.apimatic.core.ErrorCase;
import io.apimatic.core.GlobalConfiguration;
import java.io.IOException;
import java.util.concurrent.CompletableFuture;
import java.util.concurrent.CompletionException;

/**
 * This class lists all the endpoints of the groups.
 */
public final class CustomerController extends BaseController {

    /**
     * Initializes the controller.
     * @param globalConfig    Configurations added in client.
     */
    public CustomerController(GlobalConfiguration globalConfig) {
        super(globalConfig);
    }

    /**
     * This API allows querying the user data of the logged in user.&lt;/br&gt; This API will return the
     * user access details such as payers and/or accounts. &lt;/br&gt; This API will also validate that
     * logged in user has access to the requested API, on failure it will return HasAPIAccess flag
     * as false in response.&lt;/br&gt;.
     * @param  apikey  Required parameter: This is the API key of the specific environment which
     *         needs to be passed by the client.
     * @param  requestId  Required parameter: Mandatory UUID (according to RFC 4122 standards) for
     *         requests and responses. This will be played back in the response from the request.
     * @param  body  Optional parameter: Logged in user request body
     * @return    Returns the LoggedInUserResponse response from the API call
     * @throws    ApiException    Represents error response from the server.
     * @throws    IOException    Signals that an I/O exception of some sort has occurred.
     */
    public LoggedInUserResponse loggedinUser(
            final String apikey,
            final String requestId,
            final LoggedInUserRequest body) throws ApiException, IOException {
        return prepareLoggedinUserRequest(apikey, requestId, body).execute();
    }

    /**
     * This API allows querying the user data of the logged in user.&lt;/br&gt; This API will return the
     * user access details such as payers and/or accounts. &lt;/br&gt; This API will also validate that
     * logged in user has access to the requested API, on failure it will return HasAPIAccess flag
     * as false in response.&lt;/br&gt;.
     * @param  apikey  Required parameter: This is the API key of the specific environment which
     *         needs to be passed by the client.
     * @param  requestId  Required parameter: Mandatory UUID (according to RFC 4122 standards) for
     *         requests and responses. This will be played back in the response from the request.
     * @param  body  Optional parameter: Logged in user request body
     * @return    Returns the LoggedInUserResponse response from the API call
     */
    public CompletableFuture<LoggedInUserResponse> loggedinUserAsync(
            final String apikey,
            final String requestId,
            final LoggedInUserRequest body) {
        try { 
            return prepareLoggedinUserRequest(apikey, requestId, body).executeAsync(); 
        } catch (Exception e) {  
            throw new CompletionException(e); 
        }
    }

    /**
     * Builds the ApiCall object for loggedinUser.
     */
    private ApiCall<LoggedInUserResponse, ApiException> prepareLoggedinUserRequest(
            final String apikey,
            final String requestId,
            final LoggedInUserRequest body) throws JsonProcessingException, IOException {
        return new ApiCall.Builder<LoggedInUserResponse, ApiException>()
                .globalConfig(getGlobalConfiguration())
                .requestBuilder(requestBuilder -> requestBuilder
                        .server(Server.SHELL.value())
                        .path("/fleetmanagement/v1/user/loggedinuser")
                        .bodyParam(param -> param.value(body).isRequired(false))
                        .bodySerializer(() ->  ApiHelper.serialize(body))
                        .headerParam(param -> param.key("apikey")
                                .value(apikey).isRequired(false))
                        .headerParam(param -> param.key("RequestId")
                                .value(requestId).isRequired(false))
                        .headerParam(param -> param.key("Content-Type")
                                .value("application/json").isRequired(false))
                        .headerParam(param -> param.key("accept").value("application/json"))
                        .withAuth(auth -> auth
                                .add("BasicAuth"))
                        .httpMethod(HttpMethod.POST))
                .responseHandler(responseHandler -> responseHandler
                        .deserializer(
                                response -> ApiHelper.deserialize(response, LoggedInUserResponse.class))
                        .nullify404(false)
                        .localErrorCase("400",
                                 ErrorCase.setReason("The server cannot or will not process the request  due to something that is perceived to be a client\r\n error (e.g., malformed request syntax, invalid \r\n request message framing, or deceptive request routing).",
                                (reason, context) -> new DefaultErrorException(reason, context)))
                        .localErrorCase("401",
                                 ErrorCase.setReason("The request has not been applied because it lacks valid  authentication credentials for the target resource.\r\n",
                                (reason, context) -> new DefaultErrorException(reason, context)))
                        .localErrorCase("403",
                                 ErrorCase.setReason("The server understood the request but refuses to authorize it.\r\n",
                                (reason, context) -> new ErrorUserAccessError1Exception(reason, context)))
                        .localErrorCase("404",
                                 ErrorCase.setReason("The origin server did not find a current representation  for the target resource or is not willing to disclose  that one exists.\r\n",
                                (reason, context) -> new DefaultErrorException(reason, context)))
                        .localErrorCase("500",
                                 ErrorCase.setReason("The server encountered an unexpected condition the prevented it from fulfilling the request.\r\n",
                                (reason, context) -> new DefaultErrorException(reason, context)))
                        .globalErrorCase(GLOBAL_ERROR_CASES))
                .build();
    }

    /**
     * This API allows querying the payer accounts details from the Shell Cards Platform. It
     * provides flexible search criteria for searching payer information and supports paging. Paging
     * is applicable only when all the payers passed in the input are from the same ColCo. However,
     * paging will be ignored and the API will return all the matching data by merging the data
     * queried from each ColCo when payers passed in the input are from multiple ColCos.
     * @param  apikey  Required parameter: This is the API key of the specific environment which
     *         needs to be passed by the client.
     * @param  requestId  Required parameter: Mandatory UUID (according to RFC 4122 standards) for
     *         requests and responses. This will be played back in the response from the request.
     * @param  body  Optional parameter: Serach payers request body
     * @return    Returns the PayerResponse response from the API call
     * @throws    ApiException    Represents error response from the server.
     * @throws    IOException    Signals that an I/O exception of some sort has occurred.
     */
    public PayerResponse payers(
            final String apikey,
            final String requestId,
            final PayerRequest body) throws ApiException, IOException {
        return preparePayersRequest(apikey, requestId, body).execute();
    }

    /**
     * This API allows querying the payer accounts details from the Shell Cards Platform. It
     * provides flexible search criteria for searching payer information and supports paging. Paging
     * is applicable only when all the payers passed in the input are from the same ColCo. However,
     * paging will be ignored and the API will return all the matching data by merging the data
     * queried from each ColCo when payers passed in the input are from multiple ColCos.
     * @param  apikey  Required parameter: This is the API key of the specific environment which
     *         needs to be passed by the client.
     * @param  requestId  Required parameter: Mandatory UUID (according to RFC 4122 standards) for
     *         requests and responses. This will be played back in the response from the request.
     * @param  body  Optional parameter: Serach payers request body
     * @return    Returns the PayerResponse response from the API call
     */
    public CompletableFuture<PayerResponse> payersAsync(
            final String apikey,
            final String requestId,
            final PayerRequest body) {
        try { 
            return preparePayersRequest(apikey, requestId, body).executeAsync(); 
        } catch (Exception e) {  
            throw new CompletionException(e); 
        }
    }

    /**
     * Builds the ApiCall object for payers.
     */
    private ApiCall<PayerResponse, ApiException> preparePayersRequest(
            final String apikey,
            final String requestId,
            final PayerRequest body) throws JsonProcessingException, IOException {
        return new ApiCall.Builder<PayerResponse, ApiException>()
                .globalConfig(getGlobalConfiguration())
                .requestBuilder(requestBuilder -> requestBuilder
                        .server(Server.SHELL.value())
                        .path("/fleetmanagement/v1/customer/payers")
                        .bodyParam(param -> param.value(body).isRequired(false))
                        .bodySerializer(() ->  ApiHelper.serialize(body))
                        .headerParam(param -> param.key("apikey")
                                .value(apikey).isRequired(false))
                        .headerParam(param -> param.key("RequestId")
                                .value(requestId).isRequired(false))
                        .headerParam(param -> param.key("Content-Type")
                                .value("application/json").isRequired(false))
                        .headerParam(param -> param.key("accept").value("application/json"))
                        .withAuth(auth -> auth
                                .add("BasicAuth"))
                        .httpMethod(HttpMethod.POST))
                .responseHandler(responseHandler -> responseHandler
                        .deserializer(
                                response -> ApiHelper.deserialize(response, PayerResponse.class))
                        .nullify404(false)
                        .localErrorCase("400",
                                 ErrorCase.setReason("The server cannot or will not process the request  due to something that is perceived to be a client\r\n error (e.g., malformed request syntax, invalid \r\n request message framing, or deceptive request routing).",
                                (reason, context) -> new DefaultErrorException(reason, context)))
                        .localErrorCase("401",
                                 ErrorCase.setReason("The request has not been applied because it lacks valid  authentication credentials for the target resource.\r\n",
                                (reason, context) -> new DefaultErrorException(reason, context)))
                        .localErrorCase("403",
                                 ErrorCase.setReason("The server understood the request but refuses to authorize it.\r\n",
                                (reason, context) -> new ErrorUserAccessError1Exception(reason, context)))
                        .localErrorCase("404",
                                 ErrorCase.setReason("The origin server did not find a current representation  for the target resource or is not willing to disclose  that one exists.\r\n",
                                (reason, context) -> new DefaultErrorException(reason, context)))
                        .localErrorCase("500",
                                 ErrorCase.setReason("The server encountered an unexpected condition the prevented it from fulfilling the request.\r\n",
                                (reason, context) -> new DefaultErrorException(reason, context)))
                        .globalErrorCase(GLOBAL_ERROR_CASES))
                .build();
    }

    /**
     * This API allows querying the card delivery addresses of a given account from the Shell Cards
     * Platform. Only active delivery addresses will be returned.
     * @param  apikey  Required parameter: This is the API key of the specific environment which
     *         needs to be passed by the client.
     * @param  requestId  Required parameter: Mandatory UUID (according to RFC 4122 standards) for
     *         requests and responses. This will be played back in the response from the request.
     * @param  body  Optional parameter: Customerdetails request body
     * @return    Returns the CustomerDetailResponse response from the API call
     * @throws    ApiException    Represents error response from the server.
     * @throws    IOException    Signals that an I/O exception of some sort has occurred.
     */
    public CustomerDetailResponse customer(
            final String apikey,
            final String requestId,
            final CustomerDetailRequest body) throws ApiException, IOException {
        return prepareCustomerRequest(apikey, requestId, body).execute();
    }

    /**
     * This API allows querying the card delivery addresses of a given account from the Shell Cards
     * Platform. Only active delivery addresses will be returned.
     * @param  apikey  Required parameter: This is the API key of the specific environment which
     *         needs to be passed by the client.
     * @param  requestId  Required parameter: Mandatory UUID (according to RFC 4122 standards) for
     *         requests and responses. This will be played back in the response from the request.
     * @param  body  Optional parameter: Customerdetails request body
     * @return    Returns the CustomerDetailResponse response from the API call
     */
    public CompletableFuture<CustomerDetailResponse> customerAsync(
            final String apikey,
            final String requestId,
            final CustomerDetailRequest body) {
        try { 
            return prepareCustomerRequest(apikey, requestId, body).executeAsync(); 
        } catch (Exception e) {  
            throw new CompletionException(e); 
        }
    }

    /**
     * Builds the ApiCall object for customer.
     */
    private ApiCall<CustomerDetailResponse, ApiException> prepareCustomerRequest(
            final String apikey,
            final String requestId,
            final CustomerDetailRequest body) throws JsonProcessingException, IOException {
        return new ApiCall.Builder<CustomerDetailResponse, ApiException>()
                .globalConfig(getGlobalConfiguration())
                .requestBuilder(requestBuilder -> requestBuilder
                        .server(Server.SHELL.value())
                        .path("/fleetmanagement/v1/customer/customer")
                        .bodyParam(param -> param.value(body).isRequired(false))
                        .bodySerializer(() ->  ApiHelper.serialize(body))
                        .headerParam(param -> param.key("apikey")
                                .value(apikey).isRequired(false))
                        .headerParam(param -> param.key("RequestId")
                                .value(requestId).isRequired(false))
                        .headerParam(param -> param.key("Content-Type")
                                .value("application/json").isRequired(false))
                        .headerParam(param -> param.key("accept").value("application/json"))
                        .withAuth(auth -> auth
                                .add("BasicAuth"))
                        .httpMethod(HttpMethod.POST))
                .responseHandler(responseHandler -> responseHandler
                        .deserializer(
                                response -> ApiHelper.deserialize(response, CustomerDetailResponse.class))
                        .nullify404(false)
                        .localErrorCase("400",
                                 ErrorCase.setReason("The server cannot or will not process the request  due to something that is perceived to be a client\r\n error (e.g., malformed request syntax, invalid \r\n request message framing, or deceptive request routing).",
                                (reason, context) -> new DefaultErrorException(reason, context)))
                        .localErrorCase("401",
                                 ErrorCase.setReason("The request has not been applied because it lacks valid  authentication credentials for the target resource.\r\n",
                                (reason, context) -> new DefaultErrorException(reason, context)))
                        .localErrorCase("403",
                                 ErrorCase.setReason("The server understood the request but refuses to authorize it.\r\n",
                                (reason, context) -> new ErrorUserAccessError1Exception(reason, context)))
                        .localErrorCase("404",
                                 ErrorCase.setReason("The origin server did not find a current representation  for the target resource or is not willing to disclose  that one exists.\r\n",
                                (reason, context) -> new DefaultErrorException(reason, context)))
                        .localErrorCase("500",
                                 ErrorCase.setReason("The server encountered an unexpected condition the prevented it from fulfilling the request.\r\n",
                                (reason, context) -> new DefaultErrorException(reason, context)))
                        .globalErrorCase(GLOBAL_ERROR_CASES))
                .build();
    }

    /**
     * - This operation fetches the International and National Price List and discount values set on
     * pump prices &amp; List Prices - It allows searching price list and discount values set on pump
     * prices that are applicable for a given customer **Note**: Accounts with cancelled status will
     * not be considered for this operation for the configured - When the search is based on
     * customer specific price list then the customer price list is returned based on the associated
     * pricing customer. - The discount values set on pump prices, which are returned by the
     * operation are always customer specific values based on the customer associated price rules.
     * @param  apikey  Required parameter: This is the API key of the specific environment which
     *         needs to be passed by the client.
     * @param  requestId  Required parameter: Mandatory UUID (according to RFC 4122 standards) for
     *         requests and responses. This will be played back in the response from the request.
     * @param  body  Optional parameter: Customerdetails request body
     * @return    Returns the CustomerPriceListResponse response from the API call
     * @throws    ApiException    Represents error response from the server.
     * @throws    IOException    Signals that an I/O exception of some sort has occurred.
     */
    public CustomerPriceListResponse customerPriceList(
            final String apikey,
            final String requestId,
            final CustomerPriceListRequest body) throws ApiException, IOException {
        return prepareCustomerPriceListRequest(apikey, requestId, body).execute();
    }

    /**
     * - This operation fetches the International and National Price List and discount values set on
     * pump prices &amp; List Prices - It allows searching price list and discount values set on pump
     * prices that are applicable for a given customer **Note**: Accounts with cancelled status will
     * not be considered for this operation for the configured - When the search is based on
     * customer specific price list then the customer price list is returned based on the associated
     * pricing customer. - The discount values set on pump prices, which are returned by the
     * operation are always customer specific values based on the customer associated price rules.
     * @param  apikey  Required parameter: This is the API key of the specific environment which
     *         needs to be passed by the client.
     * @param  requestId  Required parameter: Mandatory UUID (according to RFC 4122 standards) for
     *         requests and responses. This will be played back in the response from the request.
     * @param  body  Optional parameter: Customerdetails request body
     * @return    Returns the CustomerPriceListResponse response from the API call
     */
    public CompletableFuture<CustomerPriceListResponse> customerPriceListAsync(
            final String apikey,
            final String requestId,
            final CustomerPriceListRequest body) {
        try { 
            return prepareCustomerPriceListRequest(apikey, requestId, body).executeAsync(); 
        } catch (Exception e) {  
            throw new CompletionException(e); 
        }
    }

    /**
     * Builds the ApiCall object for customerPriceList.
     */
    private ApiCall<CustomerPriceListResponse, ApiException> prepareCustomerPriceListRequest(
            final String apikey,
            final String requestId,
            final CustomerPriceListRequest body) throws JsonProcessingException, IOException {
        return new ApiCall.Builder<CustomerPriceListResponse, ApiException>()
                .globalConfig(getGlobalConfiguration())
                .requestBuilder(requestBuilder -> requestBuilder
                        .server(Server.SHELL.value())
                        .path("/fleetmanagement/v2/customer/pricelist")
                        .bodyParam(param -> param.value(body).isRequired(false))
                        .bodySerializer(() ->  ApiHelper.serialize(body))
                        .headerParam(param -> param.key("apikey")
                                .value(apikey).isRequired(false))
                        .headerParam(param -> param.key("RequestId")
                                .value(requestId).isRequired(false))
                        .headerParam(param -> param.key("Content-Type")
                                .value("application/json").isRequired(false))
                        .headerParam(param -> param.key("accept").value("application/json"))
                        .withAuth(auth -> auth
                                .add("BasicAuth"))
                        .httpMethod(HttpMethod.POST))
                .responseHandler(responseHandler -> responseHandler
                        .deserializer(
                                response -> ApiHelper.deserialize(response, CustomerPriceListResponse.class))
                        .nullify404(false)
                        .localErrorCase("400",
                                 ErrorCase.setReason("The server cannot or will not process the request  due to something that is perceived to be a client\r\n error (e.g., malformed request syntax, invalid \r\n request message framing, or deceptive request routing).",
                                (reason, context) -> new DefaultErrorException(reason, context)))
                        .localErrorCase("401",
                                 ErrorCase.setReason("The request has not been applied because it lacks valid  authentication credentials for the target resource.\r\n",
                                (reason, context) -> new DefaultErrorException(reason, context)))
                        .localErrorCase("403",
                                 ErrorCase.setReason("The server understood the request but refuses to authorize it.\r\n",
                                (reason, context) -> new ErrorUserAccessError1Exception(reason, context)))
                        .localErrorCase("404",
                                 ErrorCase.setReason("The origin server did not find a current representation  for the target resource or is not willing to disclose  that one exists.\r\n",
                                (reason, context) -> new DefaultErrorException(reason, context)))
                        .localErrorCase("500",
                                 ErrorCase.setReason("The server encountered an unexpected condition the prevented it from fulfilling the request.\r\n",
                                (reason, context) -> new DefaultErrorException(reason, context)))
                        .globalErrorCase(GLOBAL_ERROR_CASES))
                .build();
    }

    /**
     * This API allows querying the customer account details from the Shell Cards Platform. It
     * provides a flexible search criterion and supports paging".
     * @param  apikey  Required parameter: This is the API key of the specific environment which
     *         needs to be passed by the client.
     * @param  requestId  Required parameter: Mandatory UUID (according to RFC 4122 standards) for
     *         requests and responses. This will be played back in the response from the request.
     * @param  body  Optional parameter: Example:
     * @return    Returns the AccountResponse response from the API call
     * @throws    ApiException    Represents error response from the server.
     * @throws    IOException    Signals that an I/O exception of some sort has occurred.
     */
    public AccountResponse accounts(
            final String apikey,
            final String requestId,
            final AccountRequest body) throws ApiException, IOException {
        return prepareAccountsRequest(apikey, requestId, body).execute();
    }

    /**
     * This API allows querying the customer account details from the Shell Cards Platform. It
     * provides a flexible search criterion and supports paging".
     * @param  apikey  Required parameter: This is the API key of the specific environment which
     *         needs to be passed by the client.
     * @param  requestId  Required parameter: Mandatory UUID (according to RFC 4122 standards) for
     *         requests and responses. This will be played back in the response from the request.
     * @param  body  Optional parameter: Example:
     * @return    Returns the AccountResponse response from the API call
     */
    public CompletableFuture<AccountResponse> accountsAsync(
            final String apikey,
            final String requestId,
            final AccountRequest body) {
        try { 
            return prepareAccountsRequest(apikey, requestId, body).executeAsync(); 
        } catch (Exception e) {  
            throw new CompletionException(e); 
        }
    }

    /**
     * Builds the ApiCall object for accounts.
     */
    private ApiCall<AccountResponse, ApiException> prepareAccountsRequest(
            final String apikey,
            final String requestId,
            final AccountRequest body) throws JsonProcessingException, IOException {
        return new ApiCall.Builder<AccountResponse, ApiException>()
                .globalConfig(getGlobalConfiguration())
                .requestBuilder(requestBuilder -> requestBuilder
                        .server(Server.SHELL.value())
                        .path("/fleetmanagement/v1/customer/accounts")
                        .bodyParam(param -> param.value(body).isRequired(false))
                        .bodySerializer(() ->  ApiHelper.serialize(body))
                        .headerParam(param -> param.key("apikey")
                                .value(apikey).isRequired(false))
                        .headerParam(param -> param.key("RequestId")
                                .value(requestId).isRequired(false))
                        .headerParam(param -> param.key("Content-Type")
                                .value("application/json").isRequired(false))
                        .headerParam(param -> param.key("accept").value("application/json"))
                        .withAuth(auth -> auth
                                .add("BasicAuth"))
                        .httpMethod(HttpMethod.POST))
                .responseHandler(responseHandler -> responseHandler
                        .deserializer(
                                response -> ApiHelper.deserialize(response, AccountResponse.class))
                        .nullify404(false)
                        .localErrorCase("400",
                                 ErrorCase.setReason("The server cannot or will not process the request  due to something that is perceived to be a client\r\n error (e.g., malformed request syntax, invalid \r\n request message framing, or deceptive request routing).",
                                (reason, context) -> new DefaultErrorException(reason, context)))
                        .localErrorCase("401",
                                 ErrorCase.setReason("The request has not been applied because it lacks valid  authentication credentials for the target resource.\r\n",
                                (reason, context) -> new DefaultErrorException(reason, context)))
                        .localErrorCase("403",
                                 ErrorCase.setReason("The server understood the request but refuses to authorize it.\r\n",
                                (reason, context) -> new ErrorUserAccessError1Exception(reason, context)))
                        .localErrorCase("404",
                                 ErrorCase.setReason("The origin server did not find a current representation  for the target resource or is not willing to disclose  that one exists.\r\n",
                                (reason, context) -> new DefaultErrorException(reason, context)))
                        .localErrorCase("500",
                                 ErrorCase.setReason("The server encountered an unexpected condition the prevented it from fulfilling the request.\r\n",
                                (reason, context) -> new DefaultErrorException(reason, context)))
                        .globalErrorCase(GLOBAL_ERROR_CASES))
                .build();
    }

    /**
     * This operation allows querying card types that are associated to the given account and are
     * allowed to be shown to users.
     * @param  apikey  Required parameter: This is the API key of the specific environment which
     *         needs to be passed by the client.
     * @param  requestId  Required parameter: Mandatory UUID (according to RFC 4122 standards) for
     *         requests and responses. This will be played back in the response from the request.
     * @param  body  Optional parameter: Get CardType Request Body
     * @return    Returns the CardTypeResponse response from the API call
     * @throws    ApiException    Represents error response from the server.
     * @throws    IOException    Signals that an I/O exception of some sort has occurred.
     */
    public CardTypeResponse cardType(
            final String apikey,
            final String requestId,
            final CardTypeRequest body) throws ApiException, IOException {
        return prepareCardTypeRequest(apikey, requestId, body).execute();
    }

    /**
     * This operation allows querying card types that are associated to the given account and are
     * allowed to be shown to users.
     * @param  apikey  Required parameter: This is the API key of the specific environment which
     *         needs to be passed by the client.
     * @param  requestId  Required parameter: Mandatory UUID (according to RFC 4122 standards) for
     *         requests and responses. This will be played back in the response from the request.
     * @param  body  Optional parameter: Get CardType Request Body
     * @return    Returns the CardTypeResponse response from the API call
     */
    public CompletableFuture<CardTypeResponse> cardTypeAsync(
            final String apikey,
            final String requestId,
            final CardTypeRequest body) {
        try { 
            return prepareCardTypeRequest(apikey, requestId, body).executeAsync(); 
        } catch (Exception e) {  
            throw new CompletionException(e); 
        }
    }

    /**
     * Builds the ApiCall object for cardType.
     */
    private ApiCall<CardTypeResponse, ApiException> prepareCardTypeRequest(
            final String apikey,
            final String requestId,
            final CardTypeRequest body) throws JsonProcessingException, IOException {
        return new ApiCall.Builder<CardTypeResponse, ApiException>()
                .globalConfig(getGlobalConfiguration())
                .requestBuilder(requestBuilder -> requestBuilder
                        .server(Server.SHELL.value())
                        .path("/fleetmanagement/v2/customer/cardtype")
                        .bodyParam(param -> param.value(body).isRequired(false))
                        .bodySerializer(() ->  ApiHelper.serialize(body))
                        .headerParam(param -> param.key("apikey")
                                .value(apikey).isRequired(false))
                        .headerParam(param -> param.key("RequestId")
                                .value(requestId).isRequired(false))
                        .headerParam(param -> param.key("Content-Type")
                                .value("application/json").isRequired(false))
                        .headerParam(param -> param.key("accept").value("application/json"))
                        .withAuth(auth -> auth
                                .add("BasicAuth"))
                        .httpMethod(HttpMethod.POST))
                .responseHandler(responseHandler -> responseHandler
                        .deserializer(
                                response -> ApiHelper.deserialize(response, CardTypeResponse.class))
                        .nullify404(false)
                        .localErrorCase("400",
                                 ErrorCase.setReason("The server cannot or will not process the request  due to something that is perceived to be a client\r\n error (e.g., malformed request syntax, invalid \r\n request message framing, or deceptive request routing).",
                                (reason, context) -> new DefaultErrorException(reason, context)))
                        .localErrorCase("401",
                                 ErrorCase.setReason("The request has not been applied because it lacks valid  authentication credentials for the target resource.\r\n",
                                (reason, context) -> new DefaultErrorException(reason, context)))
                        .localErrorCase("403",
                                 ErrorCase.setReason("The server understood the request but refuses to authorize it.\r\n",
                                (reason, context) -> new ErrorUserAccessError1Exception(reason, context)))
                        .localErrorCase("404",
                                 ErrorCase.setReason("The origin server did not find a current representation  for the target resource or is not willing to disclose  that one exists.\r\n",
                                (reason, context) -> new DefaultErrorException(reason, context)))
                        .localErrorCase("500",
                                 ErrorCase.setReason("The server encountered an unexpected condition the prevented it from fulfilling the request.\r\n",
                                (reason, context) -> new DefaultErrorException(reason, context)))
                        .globalErrorCase(GLOBAL_ERROR_CASES))
                .build();
    }

    /**
     * This operation allows querying the card group details . It provides flexible search criteria
     * and supports paging.\ When the card group type is configured as ‘Vertical’ in cards platform,
     * this operation will return all card groups from the given account or if no account is passed
     * in the input, then will return card groups from all the accounts under the payer. When the
     * card group type is configured as ‘Horizontal’ in cards platform, this API will return all
     * card groups configured directly under the payer. Accounts with cancelled status will not be
     * considered for cardgroups search for the configured (E.g., SFH) set of client apps.
     * @param  apikey  Required parameter: This is the API key of the specific environment which
     *         needs to be passed by the client.
     * @param  requestId  Required parameter: Mandatory UUID (according to RFC 4122 standards) for
     *         requests and responses. This will be played back in the response from the request.
     * @param  body  Optional parameter: Request Body
     * @return    Returns the CardGroupResponse response from the API call
     * @throws    ApiException    Represents error response from the server.
     * @throws    IOException    Signals that an I/O exception of some sort has occurred.
     */
    public CardGroupResponse cardGroups(
            final String apikey,
            final String requestId,
            final CardGroupRequest body) throws ApiException, IOException {
        return prepareCardGroupsRequest(apikey, requestId, body).execute();
    }

    /**
     * This operation allows querying the card group details . It provides flexible search criteria
     * and supports paging.\ When the card group type is configured as ‘Vertical’ in cards platform,
     * this operation will return all card groups from the given account or if no account is passed
     * in the input, then will return card groups from all the accounts under the payer. When the
     * card group type is configured as ‘Horizontal’ in cards platform, this API will return all
     * card groups configured directly under the payer. Accounts with cancelled status will not be
     * considered for cardgroups search for the configured (E.g., SFH) set of client apps.
     * @param  apikey  Required parameter: This is the API key of the specific environment which
     *         needs to be passed by the client.
     * @param  requestId  Required parameter: Mandatory UUID (according to RFC 4122 standards) for
     *         requests and responses. This will be played back in the response from the request.
     * @param  body  Optional parameter: Request Body
     * @return    Returns the CardGroupResponse response from the API call
     */
    public CompletableFuture<CardGroupResponse> cardGroupsAsync(
            final String apikey,
            final String requestId,
            final CardGroupRequest body) {
        try { 
            return prepareCardGroupsRequest(apikey, requestId, body).executeAsync(); 
        } catch (Exception e) {  
            throw new CompletionException(e); 
        }
    }

    /**
     * Builds the ApiCall object for cardGroups.
     */
    private ApiCall<CardGroupResponse, ApiException> prepareCardGroupsRequest(
            final String apikey,
            final String requestId,
            final CardGroupRequest body) throws JsonProcessingException, IOException {
        return new ApiCall.Builder<CardGroupResponse, ApiException>()
                .globalConfig(getGlobalConfiguration())
                .requestBuilder(requestBuilder -> requestBuilder
                        .server(Server.SHELL.value())
                        .path("/fleetmanagement/v1/customer/cardgroups")
                        .bodyParam(param -> param.value(body).isRequired(false))
                        .bodySerializer(() ->  ApiHelper.serialize(body))
                        .headerParam(param -> param.key("apikey")
                                .value(apikey).isRequired(false))
                        .headerParam(param -> param.key("RequestId")
                                .value(requestId).isRequired(false))
                        .headerParam(param -> param.key("Content-Type")
                                .value("application/json").isRequired(false))
                        .headerParam(param -> param.key("accept").value("application/json"))
                        .withAuth(auth -> auth
                                .add("BasicAuth"))
                        .httpMethod(HttpMethod.POST))
                .responseHandler(responseHandler -> responseHandler
                        .deserializer(
                                response -> ApiHelper.deserialize(response, CardGroupResponse.class))
                        .nullify404(false)
                        .localErrorCase("400",
                                 ErrorCase.setReason("The server cannot or will not process the request  due to something that is perceived to be a client\r\n error (e.g., malformed request syntax, invalid \r\n request message framing, or deceptive request routing).",
                                (reason, context) -> new DefaultErrorException(reason, context)))
                        .localErrorCase("401",
                                 ErrorCase.setReason("The request has not been applied because it lacks valid  authentication credentials for the target resource.\r\n",
                                (reason, context) -> new DefaultErrorException(reason, context)))
                        .localErrorCase("403",
                                 ErrorCase.setReason("The server understood the request but refuses to authorize it.\r\n",
                                (reason, context) -> new ErrorUserAccessError1Exception(reason, context)))
                        .localErrorCase("404",
                                 ErrorCase.setReason("The origin server did not find a current representation  for the target resource or is not willing to disclose  that one exists.\r\n",
                                (reason, context) -> new DefaultErrorException(reason, context)))
                        .localErrorCase("500",
                                 ErrorCase.setReason("The server encountered an unexpected condition the prevented it from fulfilling the request.\r\n",
                                (reason, context) -> new DefaultErrorException(reason, context)))
                        .globalErrorCase(GLOBAL_ERROR_CASES))
                .build();
    }

    /**
     * This operation allows users to fetch audit data of account or card operations performed by
     * users of a given customer The audit data includes details of below API operations * Order
     * Card * Create Card Group * PIN reminder * Move Cards * Update Card Status * Update Card Group
     * * Auto renew * Bulk card order * Bulk card block * Bulk Card Order (Multi Account) *
     * BCOSummary * BCOMultiAccountSummary * BCBSummary * Mobile Payment * Registration * Fund
     * Transfer (Scheduled &amp; Realtime) * Delivery Address Update.
     * @param  apikey  Required parameter: This is the API key of the specific environment which
     *         needs to be passed by the client.
     * @param  requestId  Required parameter: Mandatory UUID (according to RFC 4122 standards) for
     *         requests and responses. This will be played back in the response from the request.
     * @param  body  Optional parameter: request body
     * @return    Returns the AuditResponse response from the API call
     * @throws    ApiException    Represents error response from the server.
     * @throws    IOException    Signals that an I/O exception of some sort has occurred.
     */
    public AuditResponse auditReport(
            final String apikey,
            final String requestId,
            final AuditRequest body) throws ApiException, IOException {
        return prepareAuditReportRequest(apikey, requestId, body).execute();
    }

    /**
     * This operation allows users to fetch audit data of account or card operations performed by
     * users of a given customer The audit data includes details of below API operations * Order
     * Card * Create Card Group * PIN reminder * Move Cards * Update Card Status * Update Card Group
     * * Auto renew * Bulk card order * Bulk card block * Bulk Card Order (Multi Account) *
     * BCOSummary * BCOMultiAccountSummary * BCBSummary * Mobile Payment * Registration * Fund
     * Transfer (Scheduled &amp; Realtime) * Delivery Address Update.
     * @param  apikey  Required parameter: This is the API key of the specific environment which
     *         needs to be passed by the client.
     * @param  requestId  Required parameter: Mandatory UUID (according to RFC 4122 standards) for
     *         requests and responses. This will be played back in the response from the request.
     * @param  body  Optional parameter: request body
     * @return    Returns the AuditResponse response from the API call
     */
    public CompletableFuture<AuditResponse> auditReportAsync(
            final String apikey,
            final String requestId,
            final AuditRequest body) {
        try { 
            return prepareAuditReportRequest(apikey, requestId, body).executeAsync(); 
        } catch (Exception e) {  
            throw new CompletionException(e); 
        }
    }

    /**
     * Builds the ApiCall object for auditReport.
     */
    private ApiCall<AuditResponse, ApiException> prepareAuditReportRequest(
            final String apikey,
            final String requestId,
            final AuditRequest body) throws JsonProcessingException, IOException {
        return new ApiCall.Builder<AuditResponse, ApiException>()
                .globalConfig(getGlobalConfiguration())
                .requestBuilder(requestBuilder -> requestBuilder
                        .server(Server.SHELL.value())
                        .path("/fleetmanagement/v1/customer/auditreport")
                        .bodyParam(param -> param.value(body).isRequired(false))
                        .bodySerializer(() ->  ApiHelper.serialize(body))
                        .headerParam(param -> param.key("apikey")
                                .value(apikey).isRequired(false))
                        .headerParam(param -> param.key("RequestId")
                                .value(requestId).isRequired(false))
                        .headerParam(param -> param.key("Content-Type")
                                .value("application/json").isRequired(false))
                        .headerParam(param -> param.key("accept").value("application/json"))
                        .withAuth(auth -> auth
                                .add("BasicAuth"))
                        .httpMethod(HttpMethod.POST))
                .responseHandler(responseHandler -> responseHandler
                        .deserializer(
                                response -> ApiHelper.deserialize(response, AuditResponse.class))
                        .nullify404(false)
                        .localErrorCase("400",
                                 ErrorCase.setReason("The server cannot or will not process the request  due to something that is perceived to be a client\r\n error (e.g., malformed request syntax, invalid \r\n request message framing, or deceptive request routing).",
                                (reason, context) -> new DefaultErrorException(reason, context)))
                        .localErrorCase("401",
                                 ErrorCase.setReason("The request has not been applied because it lacks valid  authentication credentials for the target resource.\r\n",
                                (reason, context) -> new DefaultErrorException(reason, context)))
                        .localErrorCase("403",
                                 ErrorCase.setReason("The server understood the request but refuses to authorize it.\r\n",
                                (reason, context) -> new ErrorUserAccessError1Exception(reason, context)))
                        .localErrorCase("404",
                                 ErrorCase.setReason("The origin server did not find a current representation  for the target resource or is not willing to disclose  that one exists.\r\n",
                                (reason, context) -> new DefaultErrorException(reason, context)))
                        .localErrorCase("500",
                                 ErrorCase.setReason("The server encountered an unexpected condition the prevented it from fulfilling the request.\r\n",
                                (reason, context) -> new DefaultErrorException(reason, context)))
                        .globalErrorCase(GLOBAL_ERROR_CASES))
                .build();
    }
}