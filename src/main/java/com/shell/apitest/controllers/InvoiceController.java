/*
 * ShellDataReportingAPIsLib
 *
 * This file was automatically generated by APIMATIC v3.0 ( https://www.apimatic.io ).
 */

package com.shell.apitest.controllers;

import com.fasterxml.jackson.core.JsonProcessingException;
import com.shell.apitest.ApiHelper;
import com.shell.apitest.Server;
import com.shell.apitest.exceptions.ApiException;
import com.shell.apitest.exceptions.InvoiceManagementV1Dates400ErrorException;
import com.shell.apitest.exceptions.InvoiceManagementV1Dates401ErrorException;
import com.shell.apitest.exceptions.InvoiceManagementV1Dates403ErrorException;
import com.shell.apitest.exceptions.InvoiceManagementV1Dates404ErrorException;
import com.shell.apitest.exceptions.InvoiceManagementV1Dates500ErrorException;
import com.shell.apitest.exceptions.InvoiceManagementV1Download400ErrorException;
import com.shell.apitest.exceptions.InvoiceManagementV1Download401ErrorException;
import com.shell.apitest.exceptions.InvoiceManagementV1Download403ErrorException;
import com.shell.apitest.exceptions.InvoiceManagementV1Download404ErrorException;
import com.shell.apitest.exceptions.InvoiceManagementV1Download500ErrorException;
import com.shell.apitest.exceptions.InvoiceManagementV1Eiddownload400ErrorException;
import com.shell.apitest.exceptions.InvoiceManagementV1Eiddownload401ErrorException;
import com.shell.apitest.exceptions.InvoiceManagementV1Eiddownload403ErrorException;
import com.shell.apitest.exceptions.InvoiceManagementV1Eiddownload404ErrorException;
import com.shell.apitest.exceptions.InvoiceManagementV1Eiddownload500ErrorException;
import com.shell.apitest.exceptions.InvoiceManagementV1Eidsearch400ErrorException;
import com.shell.apitest.exceptions.InvoiceManagementV1Eidsearch401ErrorException;
import com.shell.apitest.exceptions.InvoiceManagementV1Eidsearch403ErrorException;
import com.shell.apitest.exceptions.InvoiceManagementV1Eidsearch404ErrorException;
import com.shell.apitest.exceptions.InvoiceManagementV1Eidsearch500ErrorException;
import com.shell.apitest.exceptions.InvoiceManagementV1Search400ErrorException;
import com.shell.apitest.exceptions.InvoiceManagementV1Search401ErrorException;
import com.shell.apitest.exceptions.InvoiceManagementV1Search403ErrorException;
import com.shell.apitest.exceptions.InvoiceManagementV1Search404ErrorException;
import com.shell.apitest.exceptions.InvoiceManagementV1Search500ErrorException;
import com.shell.apitest.exceptions.InvoiceManagementV1Searchdocuments400ErrorException;
import com.shell.apitest.exceptions.InvoiceManagementV1Searchdocuments401ErrorException;
import com.shell.apitest.exceptions.InvoiceManagementV1Searchdocuments403ErrorException;
import com.shell.apitest.exceptions.InvoiceManagementV1Searchdocuments404ErrorException;
import com.shell.apitest.exceptions.InvoiceManagementV1Searchdocuments500ErrorException;
import com.shell.apitest.exceptions.InvoiceManagementV1Searchstatementofaccount400ErrorException;
import com.shell.apitest.exceptions.InvoiceManagementV1Searchstatementofaccount401ErrorException;
import com.shell.apitest.exceptions.InvoiceManagementV1Searchstatementofaccount403ErrorException;
import com.shell.apitest.exceptions.InvoiceManagementV1Searchstatementofaccount404ErrorException;
import com.shell.apitest.exceptions.InvoiceManagementV1Searchstatementofaccount500ErrorException;
import com.shell.apitest.exceptions.InvoiceManagementV1Statementofaccount400ErrorException;
import com.shell.apitest.exceptions.InvoiceManagementV1Statementofaccount401ErrorException;
import com.shell.apitest.exceptions.InvoiceManagementV1Statementofaccount403ErrorException;
import com.shell.apitest.exceptions.InvoiceManagementV1Statementofaccount404ErrorException;
import com.shell.apitest.exceptions.InvoiceManagementV1Statementofaccount500ErrorException;
import com.shell.apitest.exceptions.InvoiceManagementV1Summary400ErrorException;
import com.shell.apitest.exceptions.InvoiceManagementV1Summary401ErrorException;
import com.shell.apitest.exceptions.InvoiceManagementV1Summary403ErrorException;
import com.shell.apitest.exceptions.InvoiceManagementV1Summary404ErrorException;
import com.shell.apitest.exceptions.InvoiceManagementV1Summary500ErrorException;
import com.shell.apitest.http.request.HttpMethod;
import com.shell.apitest.models.EIDDocumentResponse;
import com.shell.apitest.models.EIDDownloadRequest;
import com.shell.apitest.models.EIDSearchRequest;
import com.shell.apitest.models.InvoiceDatesRequest;
import com.shell.apitest.models.InvoiceDatesResponseData;
import com.shell.apitest.models.InvoiceDownloadRequest;
import com.shell.apitest.models.InvoiceSearchRequest;
import com.shell.apitest.models.InvoiceSearchResponse;
import com.shell.apitest.models.InvoiceSummaryRequest;
import com.shell.apitest.models.InvoiceSummaryResponse;
import com.shell.apitest.models.SearchDocumentsRequest;
import com.shell.apitest.models.SearchDocumentsResponse;
import com.shell.apitest.models.SearchStatementOfAccountRequest;
import com.shell.apitest.models.SearchStatementOfAccountResponse;
import com.shell.apitest.models.StatementOfAccountRequest;
import com.shell.apitest.models.StatementOfAccountResponse;
import io.apimatic.core.ApiCall;
import io.apimatic.core.ErrorCase;
import io.apimatic.core.GlobalConfiguration;
import java.io.IOException;
import java.io.InputStream;
import java.util.concurrent.CompletableFuture;
import java.util.concurrent.CompletionException;

/**
 * This class lists all the endpoints of the groups.
 */
public final class InvoiceController extends BaseController {

    /**
     * Initializes the controller.
     * @param globalConfig    Configurations added in client.
     */
    public InvoiceController(GlobalConfiguration globalConfig) {
        super(globalConfig);
    }

    /**
     * This API allows to search invoice data in the Shell Card Platform. It provides flexible
     * search criteria in the request body and supports paging. This API will also query the
     * relevant invoice documents list and return a reference number that can be used to download
     * invoice documents (PDF and Proofing elements in a zip file). #### Supported operations *
     * Search invoices by account * Search invoices by invoice type or invoice status * Search
     * invoices by invoice id or number * Search invoices by invoiced country * Search invoices
     * including einvoices * Search invoices by summary document * Search invoices by statement of
     * account * Search invoices by fixed and custom date periods.
     * @param  requestId  Required parameter: Mandatory UUID (according to RFC 4122 standards) for
     *         requests and responses. This will be played back in the response from the request.
     * @param  body  Optional parameter: Invoice Search RequestBody
     * @return    Returns the InvoiceSearchResponse response from the API call
     * @throws    ApiException    Represents error response from the server.
     * @throws    IOException    Signals that an I/O exception of some sort has occurred.
     */
    public InvoiceSearchResponse invoiceSearch(
            final String requestId,
            final InvoiceSearchRequest body) throws ApiException, IOException {
        return prepareInvoiceSearchRequest(requestId, body).execute();
    }

    /**
     * This API allows to search invoice data in the Shell Card Platform. It provides flexible
     * search criteria in the request body and supports paging. This API will also query the
     * relevant invoice documents list and return a reference number that can be used to download
     * invoice documents (PDF and Proofing elements in a zip file). #### Supported operations *
     * Search invoices by account * Search invoices by invoice type or invoice status * Search
     * invoices by invoice id or number * Search invoices by invoiced country * Search invoices
     * including einvoices * Search invoices by summary document * Search invoices by statement of
     * account * Search invoices by fixed and custom date periods.
     * @param  requestId  Required parameter: Mandatory UUID (according to RFC 4122 standards) for
     *         requests and responses. This will be played back in the response from the request.
     * @param  body  Optional parameter: Invoice Search RequestBody
     * @return    Returns the InvoiceSearchResponse response from the API call
     */
    public CompletableFuture<InvoiceSearchResponse> invoiceSearchAsync(
            final String requestId,
            final InvoiceSearchRequest body) {
        try { 
            return prepareInvoiceSearchRequest(requestId, body).executeAsync(); 
        } catch (Exception e) {  
            throw new CompletionException(e); 
        }
    }

    /**
     * Builds the ApiCall object for invoiceSearch.
     */
    private ApiCall<InvoiceSearchResponse, ApiException> prepareInvoiceSearchRequest(
            final String requestId,
            final InvoiceSearchRequest body) throws JsonProcessingException, IOException {
        return new ApiCall.Builder<InvoiceSearchResponse, ApiException>()
                .globalConfig(getGlobalConfiguration())
                .requestBuilder(requestBuilder -> requestBuilder
                        .server(Server.SHELL.value())
                        .path("/invoice-management/v1/search")
                        .bodyParam(param -> param.value(body).isRequired(false))
                        .bodySerializer(() ->  ApiHelper.serialize(body))
                        .headerParam(param -> param.key("RequestId")
                                .value(requestId).isRequired(false))
                        .headerParam(param -> param.key("Content-Type")
                                .value("application/json").isRequired(false))
                        .headerParam(param -> param.key("accept").value("application/json"))
                        .withAuth(auth -> auth
                                .add("BearerToken"))
                        .httpMethod(HttpMethod.POST))
                .responseHandler(responseHandler -> responseHandler
                        .deserializer(
                                response -> ApiHelper.deserialize(response, InvoiceSearchResponse.class))
                        .nullify404(false)
                        .localErrorCase("400",
                                 ErrorCase.setReason("The server cannot or will not process the request due to something that is perceived to be a client error (e.g., malformed request syntax, invalid request message framing, or deceptive request routing).",
                                (reason, context) -> new InvoiceManagementV1Search400ErrorException(reason, context)))
                        .localErrorCase("401",
                                 ErrorCase.setReason("The request has not been applied because it lacks valid  authentication credentials for the target resource.",
                                (reason, context) -> new InvoiceManagementV1Search401ErrorException(reason, context)))
                        .localErrorCase("403",
                                 ErrorCase.setReason("Forbidden",
                                (reason, context) -> new InvoiceManagementV1Search403ErrorException(reason, context)))
                        .localErrorCase("404",
                                 ErrorCase.setReason("The origin server did not find a current representation  for the target resource or is not willing to disclose  that one exists.",
                                (reason, context) -> new InvoiceManagementV1Search404ErrorException(reason, context)))
                        .localErrorCase("500",
                                 ErrorCase.setReason("The server encountered an unexpected condition that  prevented it from fulfilling the request.",
                                (reason, context) -> new InvoiceManagementV1Search500ErrorException(reason, context)))
                        .globalErrorCase(GLOBAL_ERROR_CASES))
                .build();
    }

    /**
     * This API returns the high level summary of invoices that match the given search criteria. The
     * same search criteria as the endpoint `/v1/invoice/search` is supported with the exception of
     * paging related parameters. #### Supported operations * Search invoices by account * Search
     * invoices by invoice type or invoice status * Search invoices by invoice id or number * Search
     * invoices by invoiced country * Search invoices including einvoices * Search invoices by
     * summary document * Search invoices by statement of account * Search invoices by fixed and
     * custom date periods.
     * @param  requestId  Required parameter: Mandatory UUID (according to RFC 4122 standards) for
     *         requests and responses. This will be played back in the response from the request.
     * @param  body  Optional parameter: Invoice Search RequestBody
     * @return    Returns the InvoiceSummaryResponse response from the API call
     * @throws    ApiException    Represents error response from the server.
     * @throws    IOException    Signals that an I/O exception of some sort has occurred.
     */
    public InvoiceSummaryResponse invoiceSummary(
            final String requestId,
            final InvoiceSummaryRequest body) throws ApiException, IOException {
        return prepareInvoiceSummaryRequest(requestId, body).execute();
    }

    /**
     * This API returns the high level summary of invoices that match the given search criteria. The
     * same search criteria as the endpoint `/v1/invoice/search` is supported with the exception of
     * paging related parameters. #### Supported operations * Search invoices by account * Search
     * invoices by invoice type or invoice status * Search invoices by invoice id or number * Search
     * invoices by invoiced country * Search invoices including einvoices * Search invoices by
     * summary document * Search invoices by statement of account * Search invoices by fixed and
     * custom date periods.
     * @param  requestId  Required parameter: Mandatory UUID (according to RFC 4122 standards) for
     *         requests and responses. This will be played back in the response from the request.
     * @param  body  Optional parameter: Invoice Search RequestBody
     * @return    Returns the InvoiceSummaryResponse response from the API call
     */
    public CompletableFuture<InvoiceSummaryResponse> invoiceSummaryAsync(
            final String requestId,
            final InvoiceSummaryRequest body) {
        try { 
            return prepareInvoiceSummaryRequest(requestId, body).executeAsync(); 
        } catch (Exception e) {  
            throw new CompletionException(e); 
        }
    }

    /**
     * Builds the ApiCall object for invoiceSummary.
     */
    private ApiCall<InvoiceSummaryResponse, ApiException> prepareInvoiceSummaryRequest(
            final String requestId,
            final InvoiceSummaryRequest body) throws JsonProcessingException, IOException {
        return new ApiCall.Builder<InvoiceSummaryResponse, ApiException>()
                .globalConfig(getGlobalConfiguration())
                .requestBuilder(requestBuilder -> requestBuilder
                        .server(Server.SHELL.value())
                        .path("/invoice-management/v1/summary")
                        .bodyParam(param -> param.value(body).isRequired(false))
                        .bodySerializer(() ->  ApiHelper.serialize(body))
                        .headerParam(param -> param.key("RequestId")
                                .value(requestId).isRequired(false))
                        .headerParam(param -> param.key("Content-Type")
                                .value("application/json").isRequired(false))
                        .headerParam(param -> param.key("accept").value("application/json"))
                        .withAuth(auth -> auth
                                .add("BearerToken"))
                        .httpMethod(HttpMethod.POST))
                .responseHandler(responseHandler -> responseHandler
                        .deserializer(
                                response -> ApiHelper.deserialize(response, InvoiceSummaryResponse.class))
                        .nullify404(false)
                        .localErrorCase("400",
                                 ErrorCase.setReason("The server cannot or will not process the request due to something that is perceived to be a client error (e.g., malformed request syntax, invalid request message framing, or deceptive request routing).",
                                (reason, context) -> new InvoiceManagementV1Summary400ErrorException(reason, context)))
                        .localErrorCase("401",
                                 ErrorCase.setReason("The request has not been applied because it lacks valid  authentication credentials for the target resource.",
                                (reason, context) -> new InvoiceManagementV1Summary401ErrorException(reason, context)))
                        .localErrorCase("403",
                                 ErrorCase.setReason("Forbidden",
                                (reason, context) -> new InvoiceManagementV1Summary403ErrorException(reason, context)))
                        .localErrorCase("404",
                                 ErrorCase.setReason("The origin server did not find a current representation  for the target resource or is not willing to disclose  that one exists.",
                                (reason, context) -> new InvoiceManagementV1Summary404ErrorException(reason, context)))
                        .localErrorCase("500",
                                 ErrorCase.setReason("The server encountered an unexpected condition that  prevented it from fulfilling the request.",
                                (reason, context) -> new InvoiceManagementV1Summary500ErrorException(reason, context)))
                        .globalErrorCase(GLOBAL_ERROR_CASES))
                .build();
    }

    /**
     * This API allows querying the details of the latest statement of account (SOA) generated for a
     * given Payer. The endpoint supports querying SOA documents by various input parameters
     * specified in the request body. #### Supported operations * Search invoice SOA by payer and
     * account * Search invoice SOA including monthly trend (last 13 months invocie trend summary) *
     * Search invoice SOA including past SOAs * Search invoice SOA including due/overdue documents *
     * Search invoice SOA including invoice summary.
     * @param  requestId  Required parameter: Mandatory UUID (according to RFC 4122 standards) for
     *         requests and responses. This will be played back in the response from the request.
     * @param  body  Optional parameter: StatementOfAccount RequestBody
     * @return    Returns the StatementOfAccountResponse response from the API call
     * @throws    ApiException    Represents error response from the server.
     * @throws    IOException    Signals that an I/O exception of some sort has occurred.
     */
    public StatementOfAccountResponse statementOfAccount(
            final String requestId,
            final StatementOfAccountRequest body) throws ApiException, IOException {
        return prepareStatementOfAccountRequest(requestId, body).execute();
    }

    /**
     * This API allows querying the details of the latest statement of account (SOA) generated for a
     * given Payer. The endpoint supports querying SOA documents by various input parameters
     * specified in the request body. #### Supported operations * Search invoice SOA by payer and
     * account * Search invoice SOA including monthly trend (last 13 months invocie trend summary) *
     * Search invoice SOA including past SOAs * Search invoice SOA including due/overdue documents *
     * Search invoice SOA including invoice summary.
     * @param  requestId  Required parameter: Mandatory UUID (according to RFC 4122 standards) for
     *         requests and responses. This will be played back in the response from the request.
     * @param  body  Optional parameter: StatementOfAccount RequestBody
     * @return    Returns the StatementOfAccountResponse response from the API call
     */
    public CompletableFuture<StatementOfAccountResponse> statementOfAccountAsync(
            final String requestId,
            final StatementOfAccountRequest body) {
        try { 
            return prepareStatementOfAccountRequest(requestId, body).executeAsync(); 
        } catch (Exception e) {  
            throw new CompletionException(e); 
        }
    }

    /**
     * Builds the ApiCall object for statementOfAccount.
     */
    private ApiCall<StatementOfAccountResponse, ApiException> prepareStatementOfAccountRequest(
            final String requestId,
            final StatementOfAccountRequest body) throws JsonProcessingException, IOException {
        return new ApiCall.Builder<StatementOfAccountResponse, ApiException>()
                .globalConfig(getGlobalConfiguration())
                .requestBuilder(requestBuilder -> requestBuilder
                        .server(Server.SHELL.value())
                        .path("/invoice-management/v1/statementofaccount")
                        .bodyParam(param -> param.value(body).isRequired(false))
                        .bodySerializer(() ->  ApiHelper.serialize(body))
                        .headerParam(param -> param.key("RequestId")
                                .value(requestId).isRequired(false))
                        .headerParam(param -> param.key("Content-Type")
                                .value("application/json").isRequired(false))
                        .headerParam(param -> param.key("accept").value("application/json"))
                        .withAuth(auth -> auth
                                .add("BearerToken"))
                        .httpMethod(HttpMethod.POST))
                .responseHandler(responseHandler -> responseHandler
                        .deserializer(
                                response -> ApiHelper.deserialize(response, StatementOfAccountResponse.class))
                        .nullify404(false)
                        .localErrorCase("400",
                                 ErrorCase.setReason("The server cannot or will not process the request due to something that is perceived to be a client error (e.g., malformed request syntax, invalid request message framing, or deceptive request routing).",
                                (reason, context) -> new InvoiceManagementV1Statementofaccount400ErrorException(reason, context)))
                        .localErrorCase("401",
                                 ErrorCase.setReason("The request has not been applied because it lacks valid  authentication credentials for the target resource.",
                                (reason, context) -> new InvoiceManagementV1Statementofaccount401ErrorException(reason, context)))
                        .localErrorCase("403",
                                 ErrorCase.setReason("Forbidden",
                                (reason, context) -> new InvoiceManagementV1Statementofaccount403ErrorException(reason, context)))
                        .localErrorCase("404",
                                 ErrorCase.setReason("The origin server did not find a current representation  for the target resource or is not willing to disclose  that one exists.",
                                (reason, context) -> new InvoiceManagementV1Statementofaccount404ErrorException(reason, context)))
                        .localErrorCase("500",
                                 ErrorCase.setReason("The server encountered an unexpected condition that  prevented it from fulfilling the request.",
                                (reason, context) -> new InvoiceManagementV1Statementofaccount500ErrorException(reason, context)))
                        .globalErrorCase(GLOBAL_ERROR_CASES))
                .build();
    }

    /**
     * - This API will return the list of Invoice Dates and Numbers for the given date range. If the
     * dates are not provided then it will fetch the data for past 13 months.
     * @param  requestId  Required parameter: Mandatory UUID (according to RFC 4122 standards) for
     *         requests and responses. This will be played back in the response from the request.
     * @param  body  Optional parameter: StatementOfAccount RequestBody
     * @return    Returns the InvoiceDatesResponseData response from the API call
     * @throws    ApiException    Represents error response from the server.
     * @throws    IOException    Signals that an I/O exception of some sort has occurred.
     */
    public InvoiceDatesResponseData dates(
            final String requestId,
            final InvoiceDatesRequest body) throws ApiException, IOException {
        return prepareDatesRequest(requestId, body).execute();
    }

    /**
     * - This API will return the list of Invoice Dates and Numbers for the given date range. If the
     * dates are not provided then it will fetch the data for past 13 months.
     * @param  requestId  Required parameter: Mandatory UUID (according to RFC 4122 standards) for
     *         requests and responses. This will be played back in the response from the request.
     * @param  body  Optional parameter: StatementOfAccount RequestBody
     * @return    Returns the InvoiceDatesResponseData response from the API call
     */
    public CompletableFuture<InvoiceDatesResponseData> datesAsync(
            final String requestId,
            final InvoiceDatesRequest body) {
        try { 
            return prepareDatesRequest(requestId, body).executeAsync(); 
        } catch (Exception e) {  
            throw new CompletionException(e); 
        }
    }

    /**
     * Builds the ApiCall object for dates.
     */
    private ApiCall<InvoiceDatesResponseData, ApiException> prepareDatesRequest(
            final String requestId,
            final InvoiceDatesRequest body) throws JsonProcessingException, IOException {
        return new ApiCall.Builder<InvoiceDatesResponseData, ApiException>()
                .globalConfig(getGlobalConfiguration())
                .requestBuilder(requestBuilder -> requestBuilder
                        .server(Server.SHELL.value())
                        .path("/invoice-management/v1/dates")
                        .bodyParam(param -> param.value(body).isRequired(false))
                        .bodySerializer(() ->  ApiHelper.serialize(body))
                        .headerParam(param -> param.key("RequestId")
                                .value(requestId).isRequired(false))
                        .headerParam(param -> param.key("Content-Type")
                                .value("application/json").isRequired(false))
                        .headerParam(param -> param.key("accept").value("application/json"))
                        .withAuth(auth -> auth
                                .add("BearerToken"))
                        .httpMethod(HttpMethod.POST))
                .responseHandler(responseHandler -> responseHandler
                        .deserializer(
                                response -> ApiHelper.deserialize(response, InvoiceDatesResponseData.class))
                        .nullify404(false)
                        .localErrorCase("400",
                                 ErrorCase.setReason("The server cannot or will not process the request due to something that is perceived to be a client error (e.g., malformed request syntax, invalid request message framing, or deceptive request routing).",
                                (reason, context) -> new InvoiceManagementV1Dates400ErrorException(reason, context)))
                        .localErrorCase("401",
                                 ErrorCase.setReason("The request has not been applied because it lacks valid  authentication credentials for the target resource.",
                                (reason, context) -> new InvoiceManagementV1Dates401ErrorException(reason, context)))
                        .localErrorCase("403",
                                 ErrorCase.setReason("Forbidden",
                                (reason, context) -> new InvoiceManagementV1Dates403ErrorException(reason, context)))
                        .localErrorCase("404",
                                 ErrorCase.setReason("The origin server did not find a current representation  for the target resource or is not willing to disclose  that one exists.",
                                (reason, context) -> new InvoiceManagementV1Dates404ErrorException(reason, context)))
                        .localErrorCase("500",
                                 ErrorCase.setReason("The server encountered an unexpected condition that  prevented it from fulfilling the request.",
                                (reason, context) -> new InvoiceManagementV1Dates500ErrorException(reason, context)))
                        .globalErrorCase(GLOBAL_ERROR_CASES))
                .build();
    }

    /**
     * - This API will allow querying of SOA from different systems.
     * @param  requestId  Required parameter: Mandatory UUID (according to RFC 4122 standards) for
     *         requests and responses. This will be played back in the response from the request.
     * @param  body  Optional parameter: searchstatementofaccount RequestBody
     * @return    Returns the SearchStatementOfAccountResponse response from the API call
     * @throws    ApiException    Represents error response from the server.
     * @throws    IOException    Signals that an I/O exception of some sort has occurred.
     */
    public SearchStatementOfAccountResponse searchStatementOfAccount(
            final String requestId,
            final SearchStatementOfAccountRequest body) throws ApiException, IOException {
        return prepareSearchStatementOfAccountRequest(requestId, body).execute();
    }

    /**
     * - This API will allow querying of SOA from different systems.
     * @param  requestId  Required parameter: Mandatory UUID (according to RFC 4122 standards) for
     *         requests and responses. This will be played back in the response from the request.
     * @param  body  Optional parameter: searchstatementofaccount RequestBody
     * @return    Returns the SearchStatementOfAccountResponse response from the API call
     */
    public CompletableFuture<SearchStatementOfAccountResponse> searchStatementOfAccountAsync(
            final String requestId,
            final SearchStatementOfAccountRequest body) {
        try { 
            return prepareSearchStatementOfAccountRequest(requestId, body).executeAsync(); 
        } catch (Exception e) {  
            throw new CompletionException(e); 
        }
    }

    /**
     * Builds the ApiCall object for searchStatementOfAccount.
     */
    private ApiCall<SearchStatementOfAccountResponse, ApiException> prepareSearchStatementOfAccountRequest(
            final String requestId,
            final SearchStatementOfAccountRequest body) throws JsonProcessingException, IOException {
        return new ApiCall.Builder<SearchStatementOfAccountResponse, ApiException>()
                .globalConfig(getGlobalConfiguration())
                .requestBuilder(requestBuilder -> requestBuilder
                        .server(Server.SHELL.value())
                        .path("/invoice-management/v1/searchstatementofaccount")
                        .bodyParam(param -> param.value(body).isRequired(false))
                        .bodySerializer(() ->  ApiHelper.serialize(body))
                        .headerParam(param -> param.key("RequestId")
                                .value(requestId).isRequired(false))
                        .headerParam(param -> param.key("Content-Type")
                                .value("application/json").isRequired(false))
                        .headerParam(param -> param.key("accept").value("application/json"))
                        .withAuth(auth -> auth
                                .add("BearerToken"))
                        .httpMethod(HttpMethod.POST))
                .responseHandler(responseHandler -> responseHandler
                        .deserializer(
                                response -> ApiHelper.deserialize(response, SearchStatementOfAccountResponse.class))
                        .nullify404(false)
                        .localErrorCase("400",
                                 ErrorCase.setReason("The server cannot or will not process the request due to something that is perceived to be a client error (e.g., malformed request syntax, invalid request message framing, or deceptive request routing).",
                                (reason, context) -> new InvoiceManagementV1Searchstatementofaccount400ErrorException(reason, context)))
                        .localErrorCase("401",
                                 ErrorCase.setReason("The request has not been applied because it lacks valid  authentication credentials for the target resource.",
                                (reason, context) -> new InvoiceManagementV1Searchstatementofaccount401ErrorException(reason, context)))
                        .localErrorCase("403",
                                 ErrorCase.setReason("Forbidden",
                                (reason, context) -> new InvoiceManagementV1Searchstatementofaccount403ErrorException(reason, context)))
                        .localErrorCase("404",
                                 ErrorCase.setReason("The origin server did not find a current representation  for the target resource or is not willing to disclose  that one exists.",
                                (reason, context) -> new InvoiceManagementV1Searchstatementofaccount404ErrorException(reason, context)))
                        .localErrorCase("500",
                                 ErrorCase.setReason("The server encountered an unexpected condition that  prevented it from fulfilling the request.",
                                (reason, context) -> new InvoiceManagementV1Searchstatementofaccount500ErrorException(reason, context)))
                        .globalErrorCase(GLOBAL_ERROR_CASES))
                .build();
    }

    /**
     * - This API allows querying the details of all invoices successfully uploaded to the Worldline
     * invoice repository and file reference numbers for downloading.
     * @param  requestId  Required parameter: Mandatory UUID (according to RFC 4122 standards) for
     *         requests and responses. This will be played back in the response from the request.
     * @param  body  Optional parameter: SearchDocuments RequestBody
     * @return    Returns the SearchDocumentsResponse response from the API call
     * @throws    ApiException    Represents error response from the server.
     * @throws    IOException    Signals that an I/O exception of some sort has occurred.
     */
    public SearchDocumentsResponse searchDocuments(
            final String requestId,
            final SearchDocumentsRequest body) throws ApiException, IOException {
        return prepareSearchDocumentsRequest(requestId, body).execute();
    }

    /**
     * - This API allows querying the details of all invoices successfully uploaded to the Worldline
     * invoice repository and file reference numbers for downloading.
     * @param  requestId  Required parameter: Mandatory UUID (according to RFC 4122 standards) for
     *         requests and responses. This will be played back in the response from the request.
     * @param  body  Optional parameter: SearchDocuments RequestBody
     * @return    Returns the SearchDocumentsResponse response from the API call
     */
    public CompletableFuture<SearchDocumentsResponse> searchDocumentsAsync(
            final String requestId,
            final SearchDocumentsRequest body) {
        try { 
            return prepareSearchDocumentsRequest(requestId, body).executeAsync(); 
        } catch (Exception e) {  
            throw new CompletionException(e); 
        }
    }

    /**
     * Builds the ApiCall object for searchDocuments.
     */
    private ApiCall<SearchDocumentsResponse, ApiException> prepareSearchDocumentsRequest(
            final String requestId,
            final SearchDocumentsRequest body) throws JsonProcessingException, IOException {
        return new ApiCall.Builder<SearchDocumentsResponse, ApiException>()
                .globalConfig(getGlobalConfiguration())
                .requestBuilder(requestBuilder -> requestBuilder
                        .server(Server.SHELL.value())
                        .path("/invoice-management/v1/searchdocuments")
                        .bodyParam(param -> param.value(body).isRequired(false))
                        .bodySerializer(() ->  ApiHelper.serialize(body))
                        .headerParam(param -> param.key("RequestId")
                                .value(requestId).isRequired(false))
                        .headerParam(param -> param.key("Content-Type")
                                .value("application/json").isRequired(false))
                        .headerParam(param -> param.key("accept").value("application/json"))
                        .withAuth(auth -> auth
                                .add("BearerToken"))
                        .httpMethod(HttpMethod.POST))
                .responseHandler(responseHandler -> responseHandler
                        .deserializer(
                                response -> ApiHelper.deserialize(response, SearchDocumentsResponse.class))
                        .nullify404(false)
                        .localErrorCase("400",
                                 ErrorCase.setReason("The server cannot or will not process the request due to something that is perceived to be a client error (e.g., malformed request syntax, invalid request message framing, or deceptive request routing).",
                                (reason, context) -> new InvoiceManagementV1Searchdocuments400ErrorException(reason, context)))
                        .localErrorCase("401",
                                 ErrorCase.setReason("The request has not been applied because it lacks valid  authentication credentials for the target resource.",
                                (reason, context) -> new InvoiceManagementV1Searchdocuments401ErrorException(reason, context)))
                        .localErrorCase("403",
                                 ErrorCase.setReason("Forbidden",
                                (reason, context) -> new InvoiceManagementV1Searchdocuments403ErrorException(reason, context)))
                        .localErrorCase("404",
                                 ErrorCase.setReason("The origin server did not find a current representation  for the target resource or is not willing to disclose  that one exists.",
                                (reason, context) -> new InvoiceManagementV1Searchdocuments404ErrorException(reason, context)))
                        .localErrorCase("500",
                                 ErrorCase.setReason("The server encountered an unexpected condition that  prevented it from fulfilling the request.",
                                (reason, context) -> new InvoiceManagementV1Searchdocuments500ErrorException(reason, context)))
                        .globalErrorCase(GLOBAL_ERROR_CASES))
                .build();
    }

    /**
     * - This API provides the functionality needed for the screen “EID FILES” in the web interface.
     * It allows retrieving a list of EIDs based on search criteria.
     * @param  requestId  Required parameter: Mandatory UUID (according to RFC 4122 standards) for
     *         requests and responses. This will be played back in the response from the request.
     * @param  body  Optional parameter: EIDSearch RequestBody
     * @return    Returns the EIDDocumentResponse response from the API call
     * @throws    ApiException    Represents error response from the server.
     * @throws    IOException    Signals that an I/O exception of some sort has occurred.
     */
    public EIDDocumentResponse eidSearch(
            final String requestId,
            final EIDSearchRequest body) throws ApiException, IOException {
        return prepareEidSearchRequest(requestId, body).execute();
    }

    /**
     * - This API provides the functionality needed for the screen “EID FILES” in the web interface.
     * It allows retrieving a list of EIDs based on search criteria.
     * @param  requestId  Required parameter: Mandatory UUID (according to RFC 4122 standards) for
     *         requests and responses. This will be played back in the response from the request.
     * @param  body  Optional parameter: EIDSearch RequestBody
     * @return    Returns the EIDDocumentResponse response from the API call
     */
    public CompletableFuture<EIDDocumentResponse> eidSearchAsync(
            final String requestId,
            final EIDSearchRequest body) {
        try { 
            return prepareEidSearchRequest(requestId, body).executeAsync(); 
        } catch (Exception e) {  
            throw new CompletionException(e); 
        }
    }

    /**
     * Builds the ApiCall object for eidSearch.
     */
    private ApiCall<EIDDocumentResponse, ApiException> prepareEidSearchRequest(
            final String requestId,
            final EIDSearchRequest body) throws JsonProcessingException, IOException {
        return new ApiCall.Builder<EIDDocumentResponse, ApiException>()
                .globalConfig(getGlobalConfiguration())
                .requestBuilder(requestBuilder -> requestBuilder
                        .server(Server.SHELL.value())
                        .path("/invoice-management/v1/eidsearch")
                        .bodyParam(param -> param.value(body).isRequired(false))
                        .bodySerializer(() ->  ApiHelper.serialize(body))
                        .headerParam(param -> param.key("RequestId")
                                .value(requestId).isRequired(false))
                        .headerParam(param -> param.key("Content-Type")
                                .value("application/json").isRequired(false))
                        .headerParam(param -> param.key("accept").value("application/json"))
                        .withAuth(auth -> auth
                                .add("BearerToken"))
                        .httpMethod(HttpMethod.POST))
                .responseHandler(responseHandler -> responseHandler
                        .deserializer(
                                response -> ApiHelper.deserialize(response, EIDDocumentResponse.class))
                        .nullify404(false)
                        .localErrorCase("400",
                                 ErrorCase.setReason("The server cannot or will not process the request due to something that is perceived to be a client error (e.g., malformed request syntax, invalid request message framing, or deceptive request routing).",
                                (reason, context) -> new InvoiceManagementV1Eidsearch400ErrorException(reason, context)))
                        .localErrorCase("401",
                                 ErrorCase.setReason("The request has not been applied because it lacks valid  authentication credentials for the target resource.",
                                (reason, context) -> new InvoiceManagementV1Eidsearch401ErrorException(reason, context)))
                        .localErrorCase("403",
                                 ErrorCase.setReason("Forbidden",
                                (reason, context) -> new InvoiceManagementV1Eidsearch403ErrorException(reason, context)))
                        .localErrorCase("404",
                                 ErrorCase.setReason("The origin server did not find a current representation  for the target resource or is not willing to disclose  that one exists.",
                                (reason, context) -> new InvoiceManagementV1Eidsearch404ErrorException(reason, context)))
                        .localErrorCase("500",
                                 ErrorCase.setReason("The server encountered an unexpected condition that  prevented it from fulfilling the request.",
                                (reason, context) -> new InvoiceManagementV1Eidsearch500ErrorException(reason, context)))
                        .globalErrorCase(GLOBAL_ERROR_CASES))
                .build();
    }

    /**
     * - This API downloads Invoice Documents i.e., ZIP file with Invoice PDF file and Proofing
     * Elements in XML format from invoice repository.
     * @param  requestId  Required parameter: Mandatory UUID (according to RFC 4122 standards) for
     *         requests and responses. This will be played back in the response from the request.
     * @param  body  Optional parameter: Invoice Download RequestBody
     * @return    Returns the InputStream response from the API call
     * @throws    ApiException    Represents error response from the server.
     * @throws    IOException    Signals that an I/O exception of some sort has occurred.
     */
    public InputStream download(
            final String requestId,
            final InvoiceDownloadRequest body) throws ApiException, IOException {
        return prepareDownloadRequest(requestId, body).execute();
    }

    /**
     * - This API downloads Invoice Documents i.e., ZIP file with Invoice PDF file and Proofing
     * Elements in XML format from invoice repository.
     * @param  requestId  Required parameter: Mandatory UUID (according to RFC 4122 standards) for
     *         requests and responses. This will be played back in the response from the request.
     * @param  body  Optional parameter: Invoice Download RequestBody
     * @return    Returns the InputStream response from the API call
     */
    public CompletableFuture<InputStream> downloadAsync(
            final String requestId,
            final InvoiceDownloadRequest body) {
        try { 
            return prepareDownloadRequest(requestId, body).executeAsync(); 
        } catch (Exception e) {  
            throw new CompletionException(e); 
        }
    }

    /**
     * Builds the ApiCall object for download.
     */
    private ApiCall<InputStream, ApiException> prepareDownloadRequest(
            final String requestId,
            final InvoiceDownloadRequest body) throws JsonProcessingException, IOException {
        return new ApiCall.Builder<InputStream, ApiException>()
                .globalConfig(getGlobalConfiguration())
                .requestBuilder(requestBuilder -> requestBuilder
                        .server(Server.SHELL.value())
                        .path("/invoice-management/v1/download")
                        .bodyParam(param -> param.value(body).isRequired(false))
                        .bodySerializer(() ->  ApiHelper.serialize(body))
                        .headerParam(param -> param.key("RequestId")
                                .value(requestId).isRequired(false))
                        .headerParam(param -> param.key("Content-Type")
                                .value("application/json").isRequired(false))
                        .withAuth(auth -> auth
                                .add("BearerToken"))
                        .httpMethod(HttpMethod.POST))
                .responseHandler(responseHandler -> responseHandler
                        .nullify404(false)
                        .localErrorCase("400",
                                 ErrorCase.setReason("The server cannot or will not process the request due to something that is perceived to be a client error (e.g., malformed request syntax, invalid request message framing, or deceptive request routing).",
                                (reason, context) -> new InvoiceManagementV1Download400ErrorException(reason, context)))
                        .localErrorCase("401",
                                 ErrorCase.setReason("The request has not been applied because it lacks valid  authentication credentials for the target resource.",
                                (reason, context) -> new InvoiceManagementV1Download401ErrorException(reason, context)))
                        .localErrorCase("403",
                                 ErrorCase.setReason("Forbidden",
                                (reason, context) -> new InvoiceManagementV1Download403ErrorException(reason, context)))
                        .localErrorCase("404",
                                 ErrorCase.setReason("The origin server did not find a current representation  for the target resource or is not willing to disclose  that one exists.",
                                (reason, context) -> new InvoiceManagementV1Download404ErrorException(reason, context)))
                        .localErrorCase("500",
                                 ErrorCase.setReason("The server encountered an unexpected condition that  prevented it from fulfilling the request.",
                                (reason, context) -> new InvoiceManagementV1Download500ErrorException(reason, context)))
                        .globalErrorCase(GLOBAL_ERROR_CASES))
                .endpointConfiguration(param -> param
                                .hasBinaryResponse(true))
                .build();
    }

    /**
     * - This service allows downloading one or more EID documents and the corresponding signature
     * material (where applicable) in one single request - The number of EID that can be downloaded
     * at once is limited to 100 documents.
     * @param  requestId  Required parameter: Mandatory UUID (according to RFC 4122 standards) for
     *         requests and responses. This will be played back in the response from the request.
     * @param  body  Optional parameter: EIDInvoice Download RequestBody
     * @return    Returns the InputStream response from the API call
     * @throws    ApiException    Represents error response from the server.
     * @throws    IOException    Signals that an I/O exception of some sort has occurred.
     */
    public InputStream eidDownload(
            final String requestId,
            final EIDDownloadRequest body) throws ApiException, IOException {
        return prepareEidDownloadRequest(requestId, body).execute();
    }

    /**
     * - This service allows downloading one or more EID documents and the corresponding signature
     * material (where applicable) in one single request - The number of EID that can be downloaded
     * at once is limited to 100 documents.
     * @param  requestId  Required parameter: Mandatory UUID (according to RFC 4122 standards) for
     *         requests and responses. This will be played back in the response from the request.
     * @param  body  Optional parameter: EIDInvoice Download RequestBody
     * @return    Returns the InputStream response from the API call
     */
    public CompletableFuture<InputStream> eidDownloadAsync(
            final String requestId,
            final EIDDownloadRequest body) {
        try { 
            return prepareEidDownloadRequest(requestId, body).executeAsync(); 
        } catch (Exception e) {  
            throw new CompletionException(e); 
        }
    }

    /**
     * Builds the ApiCall object for eidDownload.
     */
    private ApiCall<InputStream, ApiException> prepareEidDownloadRequest(
            final String requestId,
            final EIDDownloadRequest body) throws JsonProcessingException, IOException {
        return new ApiCall.Builder<InputStream, ApiException>()
                .globalConfig(getGlobalConfiguration())
                .requestBuilder(requestBuilder -> requestBuilder
                        .server(Server.SHELL.value())
                        .path("/invoice-management/v1/eiddownload")
                        .bodyParam(param -> param.value(body).isRequired(false))
                        .bodySerializer(() ->  ApiHelper.serialize(body))
                        .headerParam(param -> param.key("RequestId")
                                .value(requestId).isRequired(false))
                        .headerParam(param -> param.key("Content-Type")
                                .value("application/json").isRequired(false))
                        .withAuth(auth -> auth
                                .add("BearerToken"))
                        .httpMethod(HttpMethod.POST))
                .responseHandler(responseHandler -> responseHandler
                        .nullify404(false)
                        .localErrorCase("400",
                                 ErrorCase.setReason("The server cannot or will not process the request due to something that is perceived to be a client error (e.g., malformed request syntax, invalid request message framing, or deceptive request routing).",
                                (reason, context) -> new InvoiceManagementV1Eiddownload400ErrorException(reason, context)))
                        .localErrorCase("401",
                                 ErrorCase.setReason("The request has not been applied because it lacks valid  authentication credentials for the target resource.",
                                (reason, context) -> new InvoiceManagementV1Eiddownload401ErrorException(reason, context)))
                        .localErrorCase("403",
                                 ErrorCase.setReason("Forbidden",
                                (reason, context) -> new InvoiceManagementV1Eiddownload403ErrorException(reason, context)))
                        .localErrorCase("404",
                                 ErrorCase.setReason("The origin server did not find a current representation  for the target resource or is not willing to disclose  that one exists.",
                                (reason, context) -> new InvoiceManagementV1Eiddownload404ErrorException(reason, context)))
                        .localErrorCase("500",
                                 ErrorCase.setReason("The server encountered an unexpected condition that  prevented it from fulfilling the request.",
                                (reason, context) -> new InvoiceManagementV1Eiddownload500ErrorException(reason, context)))
                        .globalErrorCase(GLOBAL_ERROR_CASES))
                .endpointConfiguration(param -> param
                                .hasBinaryResponse(true))
                .build();
    }
}